# Copied from https://github.com/google/iree/blob/main/build_tools/cmake/cmake_cc_library.cmake
# Copyright 2019 The IREE Authors
#
# Licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

include_guard(GLOBAL)

include(CMakeParseArguments)
include(cmake_macros)

# cmake_py_library()
#
# CMake function to imitate Bazel's py_library rule.
#
# Parameters:
# NAME: name of target (see Note)
# SRCS: List of source files for the library
# GENERATED_SRCS: List of source files for the library that are generated by other targets
# DATA: List of other targets and files required for this binary
# DEPS: List of other libraries to be linked in to the binary targets
# PUBLIC: Add this so that this library will be exported under iree::
# Also in IDE, target will appear in IREE folder while non PUBLIC will be in IREE/internal.
# TESTONLY: When added, this target will only be built if user passes -DIREE_BUILD_TESTS=ON to CMake.
#
# Note:
# By default, cmake_py_library will always create a library named cmake_${NAME},
# and alias target iree::${NAME}. The iree:: form should always be used.
# This is to reduce namespace pollution.
#
function(cmake_py_library)
  cmake_parse_arguments(
    _RULE
    "PUBLIC;TESTONLY"
    "NAME"
    "SRCS;GENERATED_SRCS;DATA;DEPS"
    ${ARGN}
  )

  if(_RULE_TESTONLY AND NOT IREE_BUILD_TESTS)
    return()
  endif()

    # TODO(boian): remove this renaming when call sites do not include ":" in target dependency names
  rename_bazel_targets(_RULE_DEPS "${_RULE_DEPS}")

  # Prefix the library with the package name, so we get: cmake_package_name.
  rename_bazel_targets(_NAME "${_RULE_NAME}")

  set(_SRCS ${_RULE_SRCS})
  # Symlink each file as its own target.
  foreach(_SRC_FILE ${_SRCS})
    if(IS_ABSOLUTE _SRC_FILE)
      message(FATAL_ERROR "Absolute path for SRCS not allowed.")
    endif()

    # _SRC_FILE could have other path components in it, so we need to make a
    # directory for it. Ninja does this automatically, but make doesn't. See
    # https://github.com/google/iree/issues/6801
    set(_SRC_BIN_PATH "${CMAKE_CURRENT_BINARY_DIR}/${_SRC_FILE}")
    get_filename_component(_SRC_BIN_DIR "${_SRC_BIN_PATH}" DIRECTORY)
    add_custom_command(
      OUTPUT "${_SRC_BIN_PATH}"
      COMMAND
        ${CMAKE_COMMAND} -E make_directory "${_SRC_BIN_DIR}"
      COMMAND ${CMAKE_COMMAND} -E create_symlink
        "${CMAKE_CURRENT_SOURCE_DIR}/${_SRC_FILE}" "${_SRC_BIN_PATH}"
      DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/${_SRC_FILE}"
      VERBATIM
    )
    list(APPEND _BIN_PATHS "${_SRC_BIN_PATH}")
  endforeach()

  foreach(_FILE ${_GENERATED_SRCS})
    if(NOT IS_ABSOLUTE _FILE)
      string(PREPEND _FILE "${CMAKE_CURRENT_BINARY_DIR}/")
    endif()
    list(APPEND _BIN_PATHS "${_FILE}")
  endforeach()

  set(_DEPS ${_RULE_DEPS} ${_BIN_PATHS})
  add_custom_target(${_NAME} ALL DEPENDS ${_DEPS})

  if(_RULE_DATA)
    rename_bazel_targets(_DATA "${_RULE_DATA}")
    add_dependencies(${_NAME} ${_DATA})
  endif()

  # If only one src file set the LOCATION target property to point to it.
  list(LENGTH _BIN_PATHS _BIN_PATHS_LENGTH)
  if(_BIN_PATHS_LENGTH EQUAL "1")
    set_target_properties(${_NAME} PROPERTIES LOCATION "${_BIN_PATHS}")
  endif()

  # TODO(boian): add install rules

endfunction()
