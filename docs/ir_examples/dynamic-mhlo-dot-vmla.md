---
layout: default
permalink: ir-examples/dynamic-mhlo-dot-vmla
title: "dynamic-mhlo-dot on vmla"
parent: IR Conversion Examples
---

# dynamic-mhlo-dot on vmla
{: .no_toc }

This is an IR conversion example auto-generated by running `iree-opt`
over [dynamic-mhlo-dot](https://github.com/google/iree/tree/main/iree/samples/ops/dynamic-mhlo-dot.mlir).

### The command

```shell
iree-opt -iree-transformation-pipeline \
  -iree-hal-target-backends=vmla \
  --print-ir-after-all \
  -mlir-disable-threading \
  -mlir-elide-elementsattrs-if-larger=8 \
  iree/samples/ops/dynamic-mhlo-dot.mlir

```
### Input IR

{% raw %}
```
func @dot(%lhs: tensor<?x?xf32>, %rhs: tensor<?x?xf32>) -> tensor<?x?xf32> attributes { iree.module.export } {
  %0 = "mhlo.dot"(%lhs, %rhs) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}
```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::SIP::MaterializeReflectionAttrsPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %0 : tensor<?x?xf32>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::HLOToHLOPreprocessingPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After RemoveShapeConstraints

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After TosaToSCF

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After TosaToStandard

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After TosaToLinalgOnTensors

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %0 : tensor<?x?xf32>
  }
}

```
{% endraw %}

### IR Dump After SCFToStandard

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After Inliner

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %0 : tensor<?x?xf32>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ConvertShapeToShapex

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %0 : tensor<?x?xf32>
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %0 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::LegalizeInputTypesPass

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %0 : tensor<?x?xf32>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::ExpandVariableDynamicDimsPass

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: tensor<?x?xf32>) -> tensor<?x?xf32> attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %0 : tensor<?x?xf32>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ExpandFunctionDynamicDimsPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %1 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %2 = "mhlo.dot"(%0, %1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  %3 = shapex.get_ranked_shape %2 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  return %2, %3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %1 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %2 = "mhlo.dot"(%0, %1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  %3 = shapex.get_ranked_shape %2 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  %4 = shapex.tie_shape %2, %3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %5 = shapex.get_ranked_shape %4 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  return %4, %5 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %1 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %2 = "mhlo.dot"(%0, %1) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  %3 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %6 = shapex.tie_shape %2, %5 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %6, %5 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %4 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  %6 = shapex.tie_shape %5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %6, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::PrePartitioningConversionPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %4 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  %6 = shapex.tie_shape %5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %6, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %4 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  %6 = shapex.tie_shape %5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %6, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::DispatchabilityAnalysisPass

{% raw %}
```
module  {
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %3 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %4 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    %6 = shapex.tie_shape %5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    return %6, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::IdentifyDispatchRegions2Pass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = shapex.ranked_dim %2[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %2[1] : !shapex.ranked_shape<[?,?]> -> index
  %5 = muli %3, %4 : index
  %6 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %7 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = flow.dispatch.region[%5 : index](%arg4 = %2 : !shapex.ranked_shape<[?,?]>, %arg5 = %8 : tensor<?x?xf32>, %arg6 = %arg3 : !shapex.ranked_shape<[?,?]>, %arg7 = %9 : tensor<?x?xf32>, %arg8 = %arg1 : !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>) {
    %12 = shapex.tie_shape %arg7, %arg8 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %13 = shapex.tie_shape %arg5, %arg6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %14 = "mhlo.dot"(%12, %13) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    %15 = shapex.tie_shape %14, %arg4 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    flow.return %15 : tensor<?x?xf32>
  }
  %11 = shapex.tie_shape %10, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %11, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = shapex.ranked_dim %2[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %2[1] : !shapex.ranked_shape<[?,?]> -> index
  %5 = muli %3, %4 : index
  %6 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %7 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %8 = flow.dispatch.region[%5 : index](%arg4 = %2 : !shapex.ranked_shape<[?,?]>, %arg5 = %6 : tensor<?x?xf32>, %arg6 = %arg3 : !shapex.ranked_shape<[?,?]>, %arg7 = %7 : tensor<?x?xf32>, %arg8 = %arg1 : !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>) {
    %10 = shapex.tie_shape %arg7, %arg8 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %11 = shapex.tie_shape %arg5, %arg6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %12 = "mhlo.dot"(%10, %11) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    %13 = shapex.tie_shape %12, %arg4 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    flow.return %13 : tensor<?x?xf32>
  }
  %9 = shapex.tie_shape %8, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %9, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::FoldCompatibleDispatchRegionsPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = shapex.ranked_dim %2[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %2[1] : !shapex.ranked_shape<[?,?]> -> index
  %5 = muli %3, %4 : index
  %6 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %7 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %8 = flow.dispatch.region[%5 : index](%arg4 = %2 : !shapex.ranked_shape<[?,?]>, %arg5 = %6 : tensor<?x?xf32>, %arg6 = %arg3 : !shapex.ranked_shape<[?,?]>, %arg7 = %7 : tensor<?x?xf32>, %arg8 = %arg1 : !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>) {
    %10 = shapex.tie_shape %arg7, %arg8 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %11 = shapex.tie_shape %arg5, %arg6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %12 = "mhlo.dot"(%10, %11) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    %13 = shapex.tie_shape %12, %arg4 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    flow.return %13 : tensor<?x?xf32>
  }
  %9 = shapex.tie_shape %8, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  return %9, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::OutlineDispatchRegionsPass

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg0, %arg1 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = shapex.tie_shape %arg2, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %5 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %3 = shapex.ranked_dim %2[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %2[1] : !shapex.ranked_shape<[?,?]> -> index
    %5 = muli %3, %4 : index
    %6 = shapex.tie_shape %arg2, %arg3 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %7 = shapex.tie_shape %arg0, %arg1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %8 = shapex.ranked_dim %2[0] : !shapex.ranked_shape<[?,?]> -> index
    %9 = shapex.ranked_dim %2[1] : !shapex.ranked_shape<[?,?]> -> index
    %10 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %11 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %12 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %13 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %14 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %15 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %16 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %17 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %18 = shapex.ranked_dim %2[0] : !shapex.ranked_shape<[?,?]> -> index
    %19 = shapex.ranked_dim %2[1] : !shapex.ranked_shape<[?,?]> -> index
    %20 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%5](%8, %9, %6, %10, %11, %7, %12, %13) : (index, index, tensor<?x?xf32>{%14, %15}, index, index, tensor<?x?xf32>{%16, %17}, index, index) -> tensor<?x?xf32>{%18, %19}
    %21 = shapex.tie_shape %20, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    return %21, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = muli %1, %0 : index
  %4 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %7 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %8 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %9 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %10 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %11 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %12 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%3](%1, %0, %arg2, %4, %5, %arg0, %6, %7) : (index, index, tensor<?x?xf32>{%8, %9}, index, index, tensor<?x?xf32>{%10, %11}, index, index) -> tensor<?x?xf32>{%1, %0}
  return %12, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::DeduplicateExecutablesPass

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg0, %arg1 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = shapex.tie_shape %arg2, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %5 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %3 = muli %1, %0 : index
    %4 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %7 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %8 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %9 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %10 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %11 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %12 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%3](%1, %0, %arg2, %4, %5, %arg0, %6, %7) : (index, index, tensor<?x?xf32>{%8, %9}, index, index, tensor<?x?xf32>{%10, %11}, index, index) -> tensor<?x?xf32>{%1, %0}
    return %12, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = muli %1, %0 : index
  %4 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %7 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %8 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %9 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %10 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %11 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %12 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%3](%1, %0, %arg2, %4, %5, %arg0, %6, %7) : (index, index, tensor<?x?xf32>{%8, %9}, index, index, tensor<?x?xf32>{%10, %11}, index, index) -> tensor<?x?xf32>{%1, %0}
  return %12, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = muli %1, %0 : index
  %4 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %7 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %8 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%3](%1, %0, %arg2, %4, %5, %arg0, %6, %7) : (index, index, tensor<?x?xf32>{%4, %5}, index, index, tensor<?x?xf32>{%6, %7}, index, index) -> tensor<?x?xf32>{%1, %0}
  return %8, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::HoistUnstreamableOps

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = muli %4, %5 : index
  %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%6](%4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5}
  return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = muli %4, %5 : index
  %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%6](%4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5}
  return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::FormStreamsPass

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = muli %4, %5 : index
  %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.make_ranked_shape %3, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %9 = shapex.ranked_dim %8[0] : !shapex.ranked_shape<[?,?]> -> index
  %10 = shapex.ranked_dim %8[1] : !shapex.ranked_shape<[?,?]> -> index
  %11 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %12 = shapex.ranked_dim %11[0] : !shapex.ranked_shape<[?,?]> -> index
  %13 = shapex.ranked_dim %11[1] : !shapex.ranked_shape<[?,?]> -> index
  %14 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %15 = shapex.ranked_dim %14[0] : !shapex.ranked_shape<[?,?]> -> index
  %16 = shapex.ranked_dim %14[1] : !shapex.ranked_shape<[?,?]> -> index
  %17 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%9, %10}, index, index, tensor<?x?xf32>{%12, %13}, index, index) -> tensor<?x?xf32>{%15, %16} =
      (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
    %18 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
    flow.return %18 : tensor<?x?xf32>
  }
  return %17, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::Flow::OutlineLargeConstantsPass

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg0, %arg1 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = shapex.tie_shape %arg2, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %5 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = shapex.make_ranked_shape %3, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %9 = shapex.ranked_dim %8[0] : !shapex.ranked_shape<[?,?]> -> index
    %10 = shapex.ranked_dim %8[1] : !shapex.ranked_shape<[?,?]> -> index
    %11 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %12 = shapex.ranked_dim %11[0] : !shapex.ranked_shape<[?,?]> -> index
    %13 = shapex.ranked_dim %11[1] : !shapex.ranked_shape<[?,?]> -> index
    %14 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %15 = shapex.ranked_dim %14[0] : !shapex.ranked_shape<[?,?]> -> index
    %16 = shapex.ranked_dim %14[1] : !shapex.ranked_shape<[?,?]> -> index
    %17 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%9, %10}, index, index, tensor<?x?xf32>{%12, %13}, index, index) -> tensor<?x?xf32>{%15, %16} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %18 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %18 : tensor<?x?xf32>
    }
    return %17, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = muli %4, %5 : index
  %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
      (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
    %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
    flow.return %9 : tensor<?x?xf32>
  }
  return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
  %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
  %6 = muli %4, %5 : index
  %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
      (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
    %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
    flow.return %9 : tensor<?x?xf32>
  }
  return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg0, %arg1 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg5, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = shapex.tie_shape %arg2, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %5 = "mhlo.dot"(%3, %4) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %5 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %4 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::IdentifyConstantPoolsPass

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %4 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeConstantPoolBuffersPass

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %4 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %4 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %4 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeInterfaces2Pass

{% raw %}
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
        %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
        %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
        %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
        return %4 : tensor<?x?xf32>
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeInterfacesPass

{% raw %}
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        func @dot_ex_dispatch_0() {
          %c0 = constant 0 : index
          %0 = hal.interface.load.constant offset = 0 : index
          %1 = hal.interface.load.constant offset = 1 : index
          %2 = hal.interface.load.constant offset = 2 : index
          %3 = hal.interface.load.constant offset = 3 : index
          %4 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
          %5 = hal.interface.load.constant offset = 4 : index
          %6 = hal.interface.load.constant offset = 5 : index
          %7 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
          %8 = call @dot_ex_dispatch_0_impl(%0, %1, %4, %2, %3, %7, %5, %6) : (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>
          hal.interface.store.tensor %8, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
          return
        }
        func private @dot_ex_dispatch_0_impl(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
          %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
          %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
          %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
          %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
          %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
          return %4 : tensor<?x?xf32>
        }
        hal.interface @legacy_io attributes {push_constants = 6 : index, sym_visibility = "private"} {
          hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: tensor<?x?xf32>, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: tensor<?x?xf32>, %arg3: !shapex.ranked_shape<[?,?]>) -> (tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = flow.ex.stream.fragment(%6, %4, %5, %arg2, %3, %2, %arg0, %1, %0) : (index, index, index, tensor<?x?xf32>{%3, %2}, index, index, tensor<?x?xf32>{%1, %0}, index, index) -> tensor<?x?xf32>{%4, %5} =
        (%arg4: index, %arg5: index, %arg6: index, %arg7: tensor<?x?xf32>, %arg8: index, %arg9: index, %arg10: tensor<?x?xf32>, %arg11: index, %arg12: index) -> tensor<?x?xf32> {
      %9 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg4](%arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12) : (index, index, tensor<?x?xf32>{%arg8, %arg9}, index, index, tensor<?x?xf32>{%arg11, %arg12}, index, index) -> tensor<?x?xf32>{%arg5, %arg6}
      flow.return %9 : tensor<?x?xf32>
    }
    return %8, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass

{% raw %}
```
hal.executable.target @vmla, filter="vmla" {
  hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
  module  {
    func @dot_ex_dispatch_0() {
      %c0 = constant 0 : index
      %0 = hal.interface.load.constant offset = 0 : index
      %1 = hal.interface.load.constant offset = 1 : index
      %2 = hal.interface.load.constant offset = 2 : index
      %3 = hal.interface.load.constant offset = 3 : index
      %4 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
      %5 = hal.interface.load.constant offset = 4 : index
      %6 = hal.interface.load.constant offset = 5 : index
      %7 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
      %8 = call @dot_ex_dispatch_0_impl(%0, %1, %4, %2, %3, %7, %5, %6) : (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>
      hal.interface.store.tensor %8, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
      return
    }
    func private @dot_ex_dispatch_0_impl(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
      %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
      %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
      %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
      %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
      %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
      return %4 : tensor<?x?xf32>
    }
    hal.interface @legacy_io attributes {push_constants = 6 : index, sym_visibility = "private"} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
module  {
  func @dot_ex_dispatch_0() {
    %c0 = constant 0 : index
    %0 = hal.interface.load.constant offset = 0 : index
    %1 = hal.interface.load.constant offset = 1 : index
    %2 = hal.interface.load.constant offset = 2 : index
    %3 = hal.interface.load.constant offset = 3 : index
    %4 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
    %5 = hal.interface.load.constant offset = 4 : index
    %6 = hal.interface.load.constant offset = 5 : index
    %7 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
    %8 = call @dot_ex_dispatch_0_impl(%0, %1, %4, %2, %3, %7, %5, %6) : (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>
    hal.interface.store.tensor %8, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
    return
  }
  func private @dot_ex_dispatch_0_impl(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
    %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %4 : tensor<?x?xf32>
  }
  hal.interface @legacy_io attributes {push_constants = 6 : index, sym_visibility = "private"} {
    hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
{% endraw %}

### IR Dump After mlir::mhlo::{anonymous}::LegalizeControlFlowPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 0 : index
  %1 = hal.interface.load.constant offset = 1 : index
  %2 = hal.interface.load.constant offset = 2 : index
  %3 = hal.interface.load.constant offset = 3 : index
  %4 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %5 = hal.interface.load.constant offset = 4 : index
  %6 = hal.interface.load.constant offset = 5 : index
  %7 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %8 = call @dot_ex_dispatch_0_impl(%0, %1, %4, %2, %3, %7, %5, %6) : (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>
  hal.interface.store.tensor %8, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::mhlo::{anonymous}::LegalizeControlFlowPass

{% raw %}
```
func private @dot_ex_dispatch_0_impl(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
  %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %4 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @dot_ex_dispatch_0_impl(%arg0: index, %arg1: index, %arg2: tensor<?x?xf32>, %arg3: index, %arg4: index, %arg5: tensor<?x?xf32>, %arg6: index, %arg7: index) -> tensor<?x?xf32> {
  %0 = shapex.make_ranked_shape %arg3, %arg4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %1 = shapex.make_ranked_shape %arg6, %arg7 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %2 = shapex.tie_shape %arg5, %1 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %3 = shapex.tie_shape %arg2, %0 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %4 = "mhlo.dot"(%2, %3) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  return %4 : tensor<?x?xf32>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 0 : index
  %1 = hal.interface.load.constant offset = 1 : index
  %2 = hal.interface.load.constant offset = 2 : index
  %3 = hal.interface.load.constant offset = 3 : index
  %4 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %5 = hal.interface.load.constant offset = 4 : index
  %6 = hal.interface.load.constant offset = 5 : index
  %7 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %8 = call @dot_ex_dispatch_0_impl(%0, %1, %4, %2, %3, %7, %5, %6) : (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>
  hal.interface.store.tensor %8, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After Inliner

{% raw %}
```
module  {
  func @dot_ex_dispatch_0() {
    %c0 = constant 0 : index
    %0 = hal.interface.load.constant offset = 2 : index
    %1 = hal.interface.load.constant offset = 3 : index
    %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
    %3 = hal.interface.load.constant offset = 4 : index
    %4 = hal.interface.load.constant offset = 5 : index
    %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
    %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
    return
  }
  hal.interface @legacy_io attributes {push_constants = 6 : index, sym_visibility = "private"} {
    hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  func @dot_ex_dispatch_0() {
    %c0 = constant 0 : index
    %0 = hal.interface.load.constant offset = 2 : index
    %1 = hal.interface.load.constant offset = 3 : index
    %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
    %3 = hal.interface.load.constant offset = 4 : index
    %4 = hal.interface.load.constant offset = 5 : index
    %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
    %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
    %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
    return
  }
  hal.interface @legacy_io attributes {push_constants = 6 : index, sym_visibility = "private"} {
    hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::DropCompilerHintsPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VMLA::UnrollReductionsPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::{anonymous}::Convert1x1ConvToDotPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = "mhlo.dot"(%8, %9) : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
  hal.interface.store.tensor %10, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VMLA::{anonymous}::PreConversionLoweringPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = shapex.get_ranked_shape %8 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  %11 = shapex.ranked_dim %10[0] : !shapex.ranked_shape<[?,?]> -> index
  %12 = shapex.ranked_dim %10[1] : !shapex.ranked_shape<[?,?]> -> index
  %13 = shapex.make_ranked_shape %c1, %11, %12 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %14 = "shapex.to_extent_tensor"(%13) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %15 = "mhlo.dynamic_reshape"(%8, %14) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %16 = shapex.get_ranked_shape %9 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  %17 = shapex.ranked_dim %16[1] : !shapex.ranked_shape<[?,?]> -> index
  %18 = shapex.ranked_dim %16[0] : !shapex.ranked_shape<[?,?]> -> index
  %19 = "mhlo.transpose"(%9) {permutation = dense<[1, 0]> : tensor<2xi64>} : (tensor<?x?xf32>) -> tensor<?x?xf32>
  %20 = shapex.make_ranked_shape %c1, %17, %18 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %21 = "shapex.to_extent_tensor"(%20) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %22 = "mhlo.dynamic_reshape"(%19, %21) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %23 = vmla.batch.matmul.pseudo %15, %22 : (tensor<?x?x?xf32>, tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %24 = "mhlo.transpose"(%23) {permutation = dense<[0, 2, 1]> : tensor<3xi64>} : (tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %25 = shapex.make_ranked_shape %11, %17 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %26 = "shapex.to_extent_tensor"(%25) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
  %27 = "mhlo.dynamic_reshape"(%24, %26) : (tensor<?x?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
  hal.interface.store.tensor %27, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = shapex.make_ranked_shape %c1, %3, %4 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = "shapex.to_extent_tensor"(%10) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %12 = "mhlo.dynamic_reshape"(%8, %11) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %13 = "mhlo.transpose"(%9) {permutation = dense<[1, 0]> : tensor<2xi64>} : (tensor<?x?xf32>) -> tensor<?x?xf32>
  %14 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %15 = "shapex.to_extent_tensor"(%14) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %16 = "mhlo.dynamic_reshape"(%13, %15) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %17 = vmla.batch.matmul.pseudo %12, %16 : (tensor<?x?x?xf32>, tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %18 = "mhlo.transpose"(%17) {permutation = dense<[0, 2, 1]> : tensor<3xi64>} : (tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %19 = shapex.make_ranked_shape %3, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %20 = "shapex.to_extent_tensor"(%19) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
  %21 = "mhlo.dynamic_reshape"(%18, %20) : (tensor<?x?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
  hal.interface.store.tensor %21, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = shapex.make_ranked_shape %c1, %3, %4 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = "shapex.to_extent_tensor"(%10) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %12 = "mhlo.dynamic_reshape"(%8, %11) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %13 = shapex.get_ranked_shape %12 : tensor<?x?x?xf32> -> !shapex.ranked_shape<[?,?,?]>
  %14 = shapex.tie_shape %12, %13 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %15 = "mhlo.transpose"(%9) {permutation = dense<[1, 0]> : tensor<2xi64>} : (tensor<?x?xf32>) -> tensor<?x?xf32>
  %16 = shapex.get_ranked_shape %15 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  %17 = shapex.tie_shape %15, %16 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %18 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %19 = "shapex.to_extent_tensor"(%18) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %20 = "mhlo.dynamic_reshape"(%17, %19) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %21 = shapex.get_ranked_shape %20 : tensor<?x?x?xf32> -> !shapex.ranked_shape<[?,?,?]>
  %22 = shapex.tie_shape %20, %21 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %23 = vmla.batch.matmul.pseudo %14, %22 : (tensor<?x?x?xf32>, tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %24 = shapex.get_ranked_shape %23 : tensor<?x?x?xf32> -> !shapex.ranked_shape<[?,?,?]>
  %25 = shapex.tie_shape %23, %24 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %26 = "mhlo.transpose"(%25) {permutation = dense<[0, 2, 1]> : tensor<3xi64>} : (tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %27 = shapex.get_ranked_shape %26 : tensor<?x?x?xf32> -> !shapex.ranked_shape<[?,?,?]>
  %28 = shapex.tie_shape %26, %27 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %29 = shapex.make_ranked_shape %3, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %30 = "shapex.to_extent_tensor"(%29) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
  %31 = "mhlo.dynamic_reshape"(%28, %30) : (tensor<?x?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
  %32 = shapex.get_ranked_shape %31 : tensor<?x?xf32> -> !shapex.ranked_shape<[?,?]>
  %33 = shapex.tie_shape %31, %32 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  hal.interface.store.tensor %33, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass

{% raw %}
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = hal.interface.load.constant offset = 2 : index
  %1 = hal.interface.load.constant offset = 3 : index
  %2 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %3 = hal.interface.load.constant offset = 4 : index
  %4 = hal.interface.load.constant offset = 5 : index
  %5 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %6 = shapex.make_ranked_shape %0, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %3, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %8 = shapex.tie_shape %5, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %9 = shapex.tie_shape %2, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %10 = shapex.make_ranked_shape %c1, %3, %4 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = "shapex.to_extent_tensor"(%10) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %12 = "mhlo.dynamic_reshape"(%8, %11) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %13 = shapex.tie_shape %12, %10 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %14 = "mhlo.transpose"(%9) {permutation = dense<[1, 0]> : tensor<2xi64>} : (tensor<?x?xf32>) -> tensor<?x?xf32>
  %15 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %16 = shapex.tie_shape %14, %15 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %17 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %18 = "shapex.to_extent_tensor"(%17) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %19 = "mhlo.dynamic_reshape"(%16, %18) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %20 = shapex.tie_shape %19, %17 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %21 = vmla.batch.matmul.pseudo %13, %20 : (tensor<?x?x?xf32>, tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %22 = shapex.make_ranked_shape %c1, %1, %3 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %23 = shapex.tie_shape %21, %22 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %24 = "mhlo.transpose"(%23) {permutation = dense<[0, 2, 1]> : tensor<3xi64>} : (tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %25 = shapex.make_ranked_shape %c1, %3, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %26 = shapex.tie_shape %24, %25 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %27 = shapex.make_ranked_shape %3, %1 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %28 = "shapex.to_extent_tensor"(%27) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
  %29 = "mhlo.dynamic_reshape"(%26, %28) : (tensor<?x?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
  %30 = shapex.tie_shape %29, %27 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  hal.interface.store.tensor %30, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations

{% raw %}
```
func @dot_ex_dispatch_0() {
  %0 = hal.interface.load.constant offset = 5 : index
  %1 = hal.interface.load.constant offset = 4 : index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = hal.interface.load.constant offset = 3 : index
  %4 = shapex.make_ranked_shape %1, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %5 = hal.interface.load.constant offset = 2 : index
  %6 = shapex.make_ranked_shape %3, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %5, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %c1 = constant 1 : index
  %8 = shapex.make_ranked_shape %c1, %1, %3 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %9 = shapex.make_ranked_shape %c1, %3, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %10 = shapex.make_ranked_shape %c1, %3, %5 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %c0 = constant 0 : index
  %12 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %13 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %14 = shapex.tie_shape %13, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %15 = shapex.tie_shape %12, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %16 = "shapex.to_extent_tensor"(%11) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %17 = "mhlo.dynamic_reshape"(%14, %16) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %18 = shapex.tie_shape %17, %11 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %19 = "mhlo.transpose"(%15) {permutation = dense<[1, 0]> : tensor<2xi64>} : (tensor<?x?xf32>) -> tensor<?x?xf32>
  %20 = shapex.tie_shape %19, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %21 = "shapex.to_extent_tensor"(%10) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %22 = "mhlo.dynamic_reshape"(%20, %21) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %23 = shapex.tie_shape %22, %10 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %24 = vmla.batch.matmul.pseudo %18, %23 : (tensor<?x?x?xf32>, tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %25 = shapex.tie_shape %24, %9 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %26 = "mhlo.transpose"(%25) {permutation = dense<[0, 2, 1]> : tensor<3xi64>} : (tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %27 = shapex.tie_shape %26, %8 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %28 = "shapex.to_extent_tensor"(%4) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
  %29 = "mhlo.dynamic_reshape"(%27, %28) : (tensor<?x?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
  %30 = shapex.tie_shape %29, %4 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  hal.interface.store.tensor %30, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot_ex_dispatch_0() {
  %0 = hal.interface.load.constant offset = 5 : index
  %1 = hal.interface.load.constant offset = 4 : index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = hal.interface.load.constant offset = 3 : index
  %4 = shapex.make_ranked_shape %1, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %5 = hal.interface.load.constant offset = 2 : index
  %6 = shapex.make_ranked_shape %3, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %5, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %c1 = constant 1 : index
  %8 = shapex.make_ranked_shape %c1, %1, %3 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %9 = shapex.make_ranked_shape %c1, %3, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %10 = shapex.make_ranked_shape %c1, %3, %5 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %c0 = constant 0 : index
  %12 = hal.interface.load.tensor @legacy_io::@arg2, offset = %c0 : tensor<?x?xf32>
  %13 = hal.interface.load.tensor @legacy_io::@arg5, offset = %c0 : tensor<?x?xf32>
  %14 = shapex.tie_shape %13, %2 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %15 = shapex.tie_shape %12, %7 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %16 = "shapex.to_extent_tensor"(%11) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %17 = "mhlo.dynamic_reshape"(%14, %16) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %18 = shapex.tie_shape %17, %11 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %19 = "mhlo.transpose"(%15) {permutation = dense<[1, 0]> : tensor<2xi64>} : (tensor<?x?xf32>) -> tensor<?x?xf32>
  %20 = shapex.tie_shape %19, %6 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  %21 = "shapex.to_extent_tensor"(%10) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
  %22 = "mhlo.dynamic_reshape"(%20, %21) : (tensor<?x?xf32>, tensor<3xindex>) -> tensor<?x?x?xf32>
  %23 = shapex.tie_shape %22, %10 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %24 = vmla.batch.matmul.pseudo %18, %23 : (tensor<?x?x?xf32>, tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %25 = shapex.tie_shape %24, %9 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %26 = "mhlo.transpose"(%25) {permutation = dense<[0, 2, 1]> : tensor<3xi64>} : (tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  %27 = shapex.tie_shape %26, %8 : tensor<?x?x?xf32>, !shapex.ranked_shape<[?,?,?]>
  %28 = "shapex.to_extent_tensor"(%4) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
  %29 = "mhlo.dynamic_reshape"(%27, %28) : (tensor<?x?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
  %30 = shapex.tie_shape %29, %4 : tensor<?x?xf32>, !shapex.ranked_shape<[?,?]>
  hal.interface.store.tensor %30, @legacy_io::@ret0, offset = %c0 : tensor<?x?xf32>
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VMLA::ConversionPass

{% raw %}
```
module  {
  func @dot_ex_dispatch_0(%arg0: !vmla.interface, %arg1: index, %arg2: index, %arg3: index) {
    %0 = vmla.interface.const %arg0 {offset = 5 : index} : index
    %1 = vmla.interface.const %arg0 {offset = 4 : index} : index
    %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %3 = vmla.interface.const %arg0 {offset = 3 : index} : index
    %4 = shapex.make_ranked_shape %1, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %5 = vmla.interface.const %arg0 {offset = 2 : index} : index
    %6 = shapex.make_ranked_shape %3, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %7 = shapex.make_ranked_shape %5, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %c1 = constant 1 : index
    %8 = shapex.make_ranked_shape %c1, %1, %3 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %9 = shapex.make_ranked_shape %c1, %3, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %10 = shapex.make_ranked_shape %c1, %3, %5 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %11 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %c0 = constant 0 : index
    %12 = vmla.interface.binding %arg0 {binding = 0 : i32, set = 0 : i32} : !vmla.buffer
    %c4 = constant 4 : index
    %13 = muli %c4, %5 : index
    %14 = muli %13, %3 : index
    %15 = vmla.buffer.view %12[%c0], byte_length = %14 : !vmla.buffer
    %16 = vmla.interface.binding %arg0 {binding = 1 : i32, set = 0 : i32} : !vmla.buffer
    %c4_0 = constant 4 : index
    %17 = muli %c4_0, %1 : index
    %18 = muli %17, %0 : index
    %19 = vmla.buffer.view %16[%c0], byte_length = %18 : !vmla.buffer
    %20 = shapex.tie_shape %19, %2 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %21 = shapex.tie_shape %15, %7 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %22 = "shapex.to_extent_tensor"(%11) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
    %23 = shapex.tie_shape %20, %11 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %c4_1 = constant 4 : index
    %24 = muli %c4_1, %3 : index
    %25 = muli %24, %5 : index
    %26 = vmla.buffer.alloc byte_length = %25 : !vmla.buffer
    vmla.transpose %21(%7 : !shapex.ranked_shape<[?,?]>), out %26(%6 : !shapex.ranked_shape<[?,?]>) {permutation = dense<[1, 0]> : tensor<2xi32>} : f32
    %27 = shapex.tie_shape %26, %6 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %28 = "shapex.to_extent_tensor"(%10) : (!shapex.ranked_shape<[?,?,?]>) -> tensor<3xindex>
    %29 = shapex.tie_shape %27, %10 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %c4_2 = constant 4 : index
    %30 = muli %c4_2, %c1 : index
    %31 = muli %30, %3 : index
    %32 = muli %31, %1 : index
    %33 = vmla.buffer.alloc byte_length = %32 : !vmla.buffer
    vmla.batch.matmul %23(%11 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, %29(%10 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, out %33(%9 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>
    %34 = shapex.tie_shape %33, %9 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %c4_3 = constant 4 : index
    %35 = muli %c4_3, %c1 : index
    %36 = muli %35, %1 : index
    %37 = muli %36, %3 : index
    %38 = vmla.buffer.alloc byte_length = %37 : !vmla.buffer
    vmla.transpose %34(%9 : !shapex.ranked_shape<[?,?,?]>), out %38(%8 : !shapex.ranked_shape<[?,?,?]>) {permutation = dense<[0, 2, 1]> : tensor<3xi32>} : f32
    %39 = shapex.tie_shape %38, %8 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %40 = "shapex.to_extent_tensor"(%4) : (!shapex.ranked_shape<[?,?]>) -> tensor<2xindex>
    %41 = shapex.tie_shape %39, %4 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %42 = vmla.interface.binding %arg0 {binding = 2 : i32, set = 0 : i32} : !vmla.buffer
    %c0_4 = constant 0 : index
    %c4_5 = constant 4 : index
    %43 = muli %c4_5, %1 : index
    %44 = muli %43, %3 : index
    vmla.buffer.copy %41[%c0_4], out %42[%c0], byte_length = %44
    return
  }
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot_ex_dispatch_0(%arg0: !vmla.interface, %arg1: index, %arg2: index, %arg3: index) {
  %0 = vmla.interface.const %arg0 {offset = 5 : index} : index
  %1 = vmla.interface.const %arg0 {offset = 4 : index} : index
  %2 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %3 = vmla.interface.const %arg0 {offset = 3 : index} : index
  %4 = shapex.make_ranked_shape %1, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %5 = vmla.interface.const %arg0 {offset = 2 : index} : index
  %6 = shapex.make_ranked_shape %3, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %5, %3 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %c1 = constant 1 : index
  %8 = shapex.make_ranked_shape %c1, %1, %3 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %9 = shapex.make_ranked_shape %c1, %3, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %10 = shapex.make_ranked_shape %c1, %3, %5 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %c0 = constant 0 : index
  %12 = vmla.interface.binding %arg0 {binding = 0 : i32, set = 0 : i32} : !vmla.buffer
  %c4 = constant 4 : index
  %13 = muli %c4, %5 : index
  %14 = muli %13, %3 : index
  %15 = vmla.buffer.view %12[%c0], byte_length = %14 : !vmla.buffer
  %16 = vmla.interface.binding %arg0 {binding = 1 : i32, set = 0 : i32} : !vmla.buffer
  %17 = muli %c4, %1 : index
  %18 = muli %17, %0 : index
  %19 = vmla.buffer.view %16[%c0], byte_length = %18 : !vmla.buffer
  %20 = shapex.tie_shape %19, %2 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
  %21 = shapex.tie_shape %15, %7 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
  %22 = shapex.tie_shape %20, %11 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %23 = muli %c4, %3 : index
  %24 = muli %23, %5 : index
  %25 = vmla.buffer.alloc byte_length = %24 : !vmla.buffer
  vmla.transpose %21(%7 : !shapex.ranked_shape<[?,?]>), out %25(%6 : !shapex.ranked_shape<[?,?]>) {permutation = dense<[1, 0]> : tensor<2xi32>} : f32
  %26 = shapex.tie_shape %25, %6 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
  %27 = shapex.tie_shape %26, %10 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %28 = muli %c4, %c1 : index
  %29 = muli %28, %3 : index
  %30 = muli %29, %1 : index
  %31 = vmla.buffer.alloc byte_length = %30 : !vmla.buffer
  vmla.batch.matmul %22(%11 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, %27(%10 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, out %31(%9 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>
  %32 = shapex.tie_shape %31, %9 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %33 = muli %28, %1 : index
  %34 = muli %33, %3 : index
  %35 = vmla.buffer.alloc byte_length = %34 : !vmla.buffer
  vmla.transpose %32(%9 : !shapex.ranked_shape<[?,?,?]>), out %35(%8 : !shapex.ranked_shape<[?,?,?]>) {permutation = dense<[0, 2, 1]> : tensor<3xi32>} : f32
  %36 = shapex.tie_shape %35, %8 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %37 = shapex.tie_shape %36, %4 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
  %38 = vmla.interface.binding %arg0 {binding = 2 : i32, set = 0 : i32} : !vmla.buffer
  %39 = muli %17, %3 : index
  vmla.buffer.copy %37[%c0], out %38[%c0], byte_length = %39
  return
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot_ex_dispatch_0(%arg0: !vmla.interface, %arg1: index, %arg2: index, %arg3: index) {
  %c1 = constant 1 : index
  %c0 = constant 0 : index
  %c4 = constant 4 : index
  %0 = vmla.interface.const %arg0 {offset = 5 : index} : index
  %1 = vmla.interface.const %arg0 {offset = 4 : index} : index
  %2 = vmla.interface.const %arg0 {offset = 3 : index} : index
  %3 = shapex.make_ranked_shape %1, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %4 = vmla.interface.const %arg0 {offset = 2 : index} : index
  %5 = shapex.make_ranked_shape %2, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %6 = shapex.make_ranked_shape %4, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %7 = shapex.make_ranked_shape %c1, %1, %2 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %8 = shapex.make_ranked_shape %c1, %2, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %9 = shapex.make_ranked_shape %c1, %2, %4 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %10 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
  %11 = vmla.interface.binding %arg0 {binding = 0 : i32, set = 0 : i32} : !vmla.buffer
  %12 = muli %4, %c4 : index
  %13 = muli %12, %2 : index
  %14 = vmla.buffer.view %11[%c0], byte_length = %13 : !vmla.buffer
  %15 = vmla.interface.binding %arg0 {binding = 1 : i32, set = 0 : i32} : !vmla.buffer
  %16 = muli %1, %c4 : index
  %17 = muli %16, %0 : index
  %18 = vmla.buffer.view %15[%c0], byte_length = %17 : !vmla.buffer
  %19 = shapex.tie_shape %14, %6 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
  %20 = shapex.tie_shape %18, %10 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %21 = muli %2, %c4 : index
  %22 = muli %21, %4 : index
  %23 = vmla.buffer.alloc byte_length = %22 : !vmla.buffer
  vmla.transpose %19(%6 : !shapex.ranked_shape<[?,?]>), out %23(%5 : !shapex.ranked_shape<[?,?]>) {permutation = dense<[1, 0]> : tensor<2xi32>} : f32
  %24 = shapex.tie_shape %23, %9 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %25 = muli %2, %c4 : index
  %26 = muli %25, %1 : index
  %27 = vmla.buffer.alloc byte_length = %26 : !vmla.buffer
  vmla.batch.matmul %20(%10 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, %24(%9 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, out %27(%8 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>
  %28 = shapex.tie_shape %27, %8 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
  %29 = muli %1, %c4 : index
  %30 = muli %29, %2 : index
  %31 = vmla.buffer.alloc byte_length = %30 : !vmla.buffer
  vmla.transpose %28(%8 : !shapex.ranked_shape<[?,?,?]>), out %31(%7 : !shapex.ranked_shape<[?,?,?]>) {permutation = dense<[0, 2, 1]> : tensor<3xi32>} : f32
  %32 = shapex.tie_shape %31, %3 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
  %33 = vmla.interface.binding %arg0 {binding = 2 : i32, set = 0 : i32} : !vmla.buffer
  %34 = muli %16, %2 : index
  vmla.buffer.copy %32[%c0], out %33[%c0], byte_length = %34
  return
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::MarkPublicSymbolsExportedPass

{% raw %}
```
module  {
  func @dot_ex_dispatch_0(%arg0: !vmla.interface, %arg1: index, %arg2: index, %arg3: index) attributes {iree.module.export} {
    %c1 = constant 1 : index
    %c0 = constant 0 : index
    %c4 = constant 4 : index
    %0 = vmla.interface.const %arg0 {offset = 5 : index} : index
    %1 = vmla.interface.const %arg0 {offset = 4 : index} : index
    %2 = vmla.interface.const %arg0 {offset = 3 : index} : index
    %3 = shapex.make_ranked_shape %1, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %4 = vmla.interface.const %arg0 {offset = 2 : index} : index
    %5 = shapex.make_ranked_shape %2, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %6 = shapex.make_ranked_shape %4, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %7 = shapex.make_ranked_shape %c1, %1, %2 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %8 = shapex.make_ranked_shape %c1, %2, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %9 = shapex.make_ranked_shape %c1, %2, %4 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %10 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %11 = vmla.interface.binding %arg0 {binding = 0 : i32, set = 0 : i32} : !vmla.buffer
    %12 = muli %4, %c4 : index
    %13 = muli %12, %2 : index
    %14 = vmla.buffer.view %11[%c0], byte_length = %13 : !vmla.buffer
    %15 = vmla.interface.binding %arg0 {binding = 1 : i32, set = 0 : i32} : !vmla.buffer
    %16 = muli %1, %c4 : index
    %17 = muli %16, %0 : index
    %18 = vmla.buffer.view %15[%c0], byte_length = %17 : !vmla.buffer
    %19 = shapex.tie_shape %14, %6 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %20 = shapex.tie_shape %18, %10 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %21 = muli %2, %c4 : index
    %22 = muli %21, %4 : index
    %23 = vmla.buffer.alloc byte_length = %22 : !vmla.buffer
    vmla.transpose %19(%6 : !shapex.ranked_shape<[?,?]>), out %23(%5 : !shapex.ranked_shape<[?,?]>) {permutation = dense<[1, 0]> : tensor<2xi32>} : f32
    %24 = shapex.tie_shape %23, %9 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %25 = muli %2, %c4 : index
    %26 = muli %25, %1 : index
    %27 = vmla.buffer.alloc byte_length = %26 : !vmla.buffer
    vmla.batch.matmul %20(%10 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, %24(%9 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, out %27(%8 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>
    %28 = shapex.tie_shape %27, %8 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %29 = muli %1, %c4 : index
    %30 = muli %29, %2 : index
    %31 = vmla.buffer.alloc byte_length = %30 : !vmla.buffer
    vmla.transpose %28(%8 : !shapex.ranked_shape<[?,?,?]>), out %31(%7 : !shapex.ranked_shape<[?,?,?]>) {permutation = dense<[0, 2, 1]> : tensor<3xi32>} : f32
    %32 = shapex.tie_shape %31, %3 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %33 = vmla.interface.binding %arg0 {binding = 2 : i32, set = 0 : i32} : !vmla.buffer
    %34 = muli %16, %2 : index
    vmla.buffer.copy %32[%c0], out %33[%c0], byte_length = %34
    return
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
module  {
  func @dot_ex_dispatch_0(%arg0: !vmla.interface, %arg1: index, %arg2: index, %arg3: index) attributes {iree.module.export} {
    %c1 = constant 1 : index
    %c0 = constant 0 : index
    %c4 = constant 4 : index
    %0 = vmla.interface.const %arg0 {offset = 5 : index} : index
    %1 = vmla.interface.const %arg0 {offset = 4 : index} : index
    %2 = vmla.interface.const %arg0 {offset = 3 : index} : index
    %3 = shapex.make_ranked_shape %1, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %4 = vmla.interface.const %arg0 {offset = 2 : index} : index
    %5 = shapex.make_ranked_shape %2, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %6 = shapex.make_ranked_shape %4, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %7 = shapex.make_ranked_shape %c1, %1, %2 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %8 = shapex.make_ranked_shape %c1, %2, %1 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %9 = shapex.make_ranked_shape %c1, %2, %4 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %10 = shapex.make_ranked_shape %c1, %1, %0 : (index, index, index) -> !shapex.ranked_shape<[?,?,?]>
    %11 = vmla.interface.binding %arg0 {binding = 0 : i32, set = 0 : i32} : !vmla.buffer
    %12 = muli %4, %c4 : index
    %13 = muli %12, %2 : index
    %14 = vmla.buffer.view %11[%c0], byte_length = %13 : !vmla.buffer
    %15 = vmla.interface.binding %arg0 {binding = 1 : i32, set = 0 : i32} : !vmla.buffer
    %16 = muli %1, %c4 : index
    %17 = muli %16, %0 : index
    %18 = vmla.buffer.view %15[%c0], byte_length = %17 : !vmla.buffer
    %19 = shapex.tie_shape %14, %6 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %20 = shapex.tie_shape %18, %10 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %21 = muli %2, %c4 : index
    %22 = muli %21, %4 : index
    %23 = vmla.buffer.alloc byte_length = %22 : !vmla.buffer
    vmla.transpose %19(%6 : !shapex.ranked_shape<[?,?]>), out %23(%5 : !shapex.ranked_shape<[?,?]>) {permutation = dense<[1, 0]> : tensor<2xi32>} : f32
    %24 = shapex.tie_shape %23, %9 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %25 = muli %2, %c4 : index
    %26 = muli %25, %1 : index
    %27 = vmla.buffer.alloc byte_length = %26 : !vmla.buffer
    vmla.batch.matmul %20(%10 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, %24(%9 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>, out %27(%8 : !shapex.ranked_shape<[?,?,?]>) : tensor<?x?x?xf32>
    %28 = shapex.tie_shape %27, %8 : !vmla.buffer, !shapex.ranked_shape<[?,?,?]>
    %29 = muli %1, %c4 : index
    %30 = muli %29, %2 : index
    %31 = vmla.buffer.alloc byte_length = %30 : !vmla.buffer
    vmla.transpose %28(%8 : !shapex.ranked_shape<[?,?,?]>), out %31(%7 : !shapex.ranked_shape<[?,?,?]>) {permutation = dense<[0, 2, 1]> : tensor<3xi32>} : f32
    %32 = shapex.tie_shape %31, %3 : !vmla.buffer, !shapex.ranked_shape<[?,?]>
    %33 = vmla.interface.binding %arg0 {binding = 2 : i32, set = 0 : i32} : !vmla.buffer
    %34 = muli %16, %2 : index
    vmla.buffer.copy %32[%c0], out %33[%c0], byte_length = %34
    return
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::ConversionPass

{% raw %}
```
module  {
  vm.module @module {
    vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.const(%value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.clone(%src : !vm.ref<!vmla.buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.byte_length(%value : !vm.ref<!vmla.buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.buffer.fill(%value : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.buffer.load.i32(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.cmp.i8(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.i16(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.i32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.f32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x8(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x16(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x32(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.finite.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i8(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i16(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.f32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.pow.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.exp.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.log.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rsqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cos.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sin.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.tanh.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.atan2.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i8(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i16(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.f32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.floor.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.ceil.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.round.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.fft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.ifft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.irfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.conv.f32f32.f32(%input : !vm.ref<!vmla.buffer>, %input_shape : i32 ..., %filter : !vm.ref<!vmla.buffer>, %filter_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_strides : i32 ..., %padding : i32 ..., %lhs_dilation : i32 ..., %rhs_dilation : i32 ..., %feature_group_count : i32, %batch_group_count : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i32i32.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i8i8.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i8 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i8 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i16i16.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i16 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i16 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.and.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.or.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c4 = vm.const.i32 4 : i32
      %c5 = vm.const.i32 5 : i32
      %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
      %c4_0 = vm.const.i32 4 : i32
      %1 = vm.call @vmla.interface.const(%arg0, %c4_0) : (!vm.ref<!vmla.interface>, i32) -> i32
      %c3 = vm.const.i32 3 : i32
      %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
      %c2 = vm.const.i32 2 : i32
      %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
      %zero_1 = vm.const.i32.zero : i32
      %zero_2 = vm.const.i32.zero : i32
      %ref = vm.call @vmla.interface.binding(%arg0, %zero_1, %zero_2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %4 = vm.mul.i32 %3, %c4 : i32
      %5 = vm.mul.i32 %4, %2 : i32
      %ref_3 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %zero_4 = vm.const.i32.zero : i32
      %c1_5 = vm.const.i32 1 : i32
      %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero_4, %c1_5) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %6 = vm.mul.i32 %1, %c4 : i32
      %7 = vm.mul.i32 %6, %0 : i32
      %ref_7 = vm.call @vmla.buffer.view(%ref_6, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %8 = vm.mul.i32 %2, %c4 : i32
      %9 = vm.mul.i32 %8, %3 : i32
      %ref_8 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
      %c1_9 = vm.const.i32 1 : i32
      %zero_10 = vm.const.i32.zero : i32
      vm.call.variadic @vmla.transpose.x32(%ref_3, [%3, %2], [%c1_9, %zero_10], %ref_8, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %10 = vm.mul.i32 %2, %c4 : i32
      %11 = vm.mul.i32 %10, %1 : i32
      %ref_11 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_7, [%c1, %1, %0], %ref_8, [%c1, %2, %3], %ref_11, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %12 = vm.mul.i32 %1, %c4 : i32
      %13 = vm.mul.i32 %12, %2 : i32
      %ref_12 = vm.call @vmla.buffer.alloc(%13) : (i32) -> !vm.ref<!vmla.buffer>
      %zero_13 = vm.const.i32.zero : i32
      %c2_14 = vm.const.i32 2 : i32
      %c1_15 = vm.const.i32 1 : i32
      vm.call.variadic @vmla.transpose.x32(%ref_11, [%c1, %2, %1], [%zero_13, %c2_14, %c1_15], %ref_12, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %zero_16 = vm.const.i32.zero : i32
      %c2_17 = vm.const.i32 2 : i32
      %ref_18 = vm.call @vmla.interface.binding(%arg0, %zero_16, %c2_17) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %14 = vm.mul.i32 %6, %2 : i32
      vm.call @vmla.buffer.copy(%ref_12, %zero, %ref_18, %zero, %14) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
      vm.return
    }
    vm.export @dot_ex_dispatch_0
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::HoistInlinedRodataPass

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.const(%value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.clone(%src : !vm.ref<!vmla.buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.byte_length(%value : !vm.ref<!vmla.buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.buffer.fill(%value : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.buffer.load.i32(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.cmp.i8(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cmp.i16(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cmp.i32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cmp.f32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.select.x8(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.select.x16(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.select.x32(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.finite.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.copy.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.copy.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.copy.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reverse.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reverse.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reverse.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pad.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pad.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pad.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.gather.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.gather.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.gather.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.scatter.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.scatter.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.scatter.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.broadcast.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.broadcast.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.broadcast.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.i8(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.i16(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.i32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.f32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.tile.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.tile.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.tile.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.not.x8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.not.x16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.not.x32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.or.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.or.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.or.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shl.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shl.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shl.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.pow.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.exp.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.log.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rsqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cos.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sin.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.tanh.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.atan2.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.i8(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.i16(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.i32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.f32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.floor.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.ceil.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.round.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.fft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.ifft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.irfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i8.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i8.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i8.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i16.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i16.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i16.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i32.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.f32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.f32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.f32.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.conv.f32f32.f32(%input : !vm.ref<!vmla.buffer>, %input_shape : i32 ..., %filter : !vm.ref<!vmla.buffer>, %filter_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_strides : i32 ..., %padding : i32 ..., %lhs_dilation : i32 ..., %rhs_dilation : i32 ..., %feature_group_count : i32, %batch_group_count : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.i32i32.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.i8i8.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i8 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i8 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.i16i16.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i16 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i16 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.and.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.or.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c4 = vm.const.i32 4 : i32
    %c5 = vm.const.i32 5 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c4_0 = vm.const.i32 4 : i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4_0) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c3 = vm.const.i32 3 : i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c2 = vm.const.i32 2 : i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %zero_1 = vm.const.i32.zero : i32
    %zero_2 = vm.const.i32.zero : i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero_1, %zero_2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_3 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %zero_4 = vm.const.i32.zero : i32
    %c1_5 = vm.const.i32 1 : i32
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero_4, %c1_5) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_7 = vm.call @vmla.buffer.view(%ref_6, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_8 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    %c1_9 = vm.const.i32 1 : i32
    %zero_10 = vm.const.i32.zero : i32
    vm.call.variadic @vmla.transpose.x32(%ref_3, [%3, %2], [%c1_9, %zero_10], %ref_8, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %2, %c4 : i32
    %11 = vm.mul.i32 %10, %1 : i32
    %ref_11 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_7, [%c1, %1, %0], %ref_8, [%c1, %2, %3], %ref_11, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %12 = vm.mul.i32 %1, %c4 : i32
    %13 = vm.mul.i32 %12, %2 : i32
    %ref_12 = vm.call @vmla.buffer.alloc(%13) : (i32) -> !vm.ref<!vmla.buffer>
    %zero_13 = vm.const.i32.zero : i32
    %c2_14 = vm.const.i32 2 : i32
    %c1_15 = vm.const.i32 1 : i32
    vm.call.variadic @vmla.transpose.x32(%ref_11, [%c1, %2, %1], [%zero_13, %c2_14, %c1_15], %ref_12, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %zero_16 = vm.const.i32.zero : i32
    %c2_17 = vm.const.i32 2 : i32
    %ref_18 = vm.call @vmla.interface.binding(%arg0, %zero_16, %c2_17) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %14 = vm.mul.i32 %6, %2 : i32
    vm.call @vmla.buffer.copy(%ref_12, %zero, %ref_18, %zero, %14) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::GlobalInitializationPass

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.const(%value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.clone(%src : !vm.ref<!vmla.buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.byte_length(%value : !vm.ref<!vmla.buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.buffer.fill(%value : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.buffer.load.i32(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.cmp.i8(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cmp.i16(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cmp.i32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cmp.f32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.select.x8(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.select.x16(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.select.x32(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.finite.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.copy.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.copy.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.copy.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reverse.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reverse.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reverse.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pad.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pad.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pad.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.gather.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.gather.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.gather.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.scatter.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.scatter.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.scatter.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.broadcast.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.broadcast.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.broadcast.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.i8(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.i16(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.i32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.iota.f32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.tile.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.tile.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.tile.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.not.x8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.not.x16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.not.x32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.and.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.or.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.or.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.or.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.xor.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shl.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shl.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shl.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.shr.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.add.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sub.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.abs.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.neg.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.mul.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.div.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rem.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.pow.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.exp.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.log.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rsqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.cos.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sin.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.tanh.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.atan2.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.min.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.max.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.i8(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.i16(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.i32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.clamp.f32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.floor.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.ceil.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.round.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.sort.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.fft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.ifft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.rfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.irfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i8.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i8.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i8.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i16.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i16.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i16.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.i32.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.f32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.f32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.convert.f32.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
  vm.import @vmla.conv.f32f32.f32(%input : !vm.ref<!vmla.buffer>, %input_shape : i32 ..., %filter : !vm.ref<!vmla.buffer>, %filter_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_strides : i32 ..., %padding : i32 ..., %lhs_dilation : i32 ..., %rhs_dilation : i32 ..., %feature_group_count : i32, %batch_group_count : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.i32i32.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.i8i8.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i8 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i8 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.i16i16.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i16 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i16 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.and.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.reduce.or.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.pooling.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c4 = vm.const.i32 4 : i32
    %c5 = vm.const.i32 5 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c4_0 = vm.const.i32 4 : i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4_0) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c3 = vm.const.i32 3 : i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c2 = vm.const.i32 2 : i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %zero_1 = vm.const.i32.zero : i32
    %zero_2 = vm.const.i32.zero : i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero_1, %zero_2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_3 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %zero_4 = vm.const.i32.zero : i32
    %c1_5 = vm.const.i32 1 : i32
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero_4, %c1_5) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_7 = vm.call @vmla.buffer.view(%ref_6, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_8 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    %c1_9 = vm.const.i32 1 : i32
    %zero_10 = vm.const.i32.zero : i32
    vm.call.variadic @vmla.transpose.x32(%ref_3, [%3, %2], [%c1_9, %zero_10], %ref_8, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %2, %c4 : i32
    %11 = vm.mul.i32 %10, %1 : i32
    %ref_11 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_7, [%c1, %1, %0], %ref_8, [%c1, %2, %3], %ref_11, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %12 = vm.mul.i32 %1, %c4 : i32
    %13 = vm.mul.i32 %12, %2 : i32
    %ref_12 = vm.call @vmla.buffer.alloc(%13) : (i32) -> !vm.ref<!vmla.buffer>
    %zero_13 = vm.const.i32.zero : i32
    %c2_14 = vm.const.i32 2 : i32
    %c1_15 = vm.const.i32 1 : i32
    vm.call.variadic @vmla.transpose.x32(%ref_11, [%c1, %2, %1], [%zero_13, %c2_14, %c1_15], %ref_12, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %zero_16 = vm.const.i32.zero : i32
    %c2_17 = vm.const.i32 2 : i32
    %ref_18 = vm.call @vmla.interface.binding(%arg0, %zero_16, %c2_17) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %14 = vm.mul.i32 %6, %2 : i32
    vm.call @vmla.buffer.copy(%ref_12, %zero, %ref_18, %zero, %14) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
  %c5 = vm.const.i32 5 : i32
  %c4 = vm.const.i32 4 : i32
  %c3 = vm.const.i32 3 : i32
  %c1 = vm.const.i32 1 : i32
  %zero = vm.const.i32.zero : i32
  %c2 = vm.const.i32 2 : i32
  %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
  %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
  %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
  %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
  %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
  %4 = vm.mul.i32 %3, %c4 : i32
  %5 = vm.mul.i32 %4, %2 : i32
  %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
  %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
  %6 = vm.mul.i32 %1, %c4 : i32
  %7 = vm.mul.i32 %6, %0 : i32
  %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
  %8 = vm.mul.i32 %2, %c4 : i32
  %9 = vm.mul.i32 %8, %3 : i32
  %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
  vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
  %10 = vm.mul.i32 %2, %c4 : i32
  %11 = vm.mul.i32 %10, %1 : i32
  %ref_4 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
  vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
  %12 = vm.mul.i32 %1, %c4 : i32
  %13 = vm.mul.i32 %12, %2 : i32
  %ref_5 = vm.call @vmla.buffer.alloc(%13) : (i32) -> !vm.ref<!vmla.buffer>
  vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
  %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
  %14 = vm.mul.i32 %6, %2 : i32
  vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %14) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
  vm.return
}

```
{% endraw %}

### IR Dump After Inliner

{% raw %}
```
module  {
  vm.module @module {
    vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.const(%value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.clone(%src : !vm.ref<!vmla.buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.byte_length(%value : !vm.ref<!vmla.buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.buffer.fill(%value : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.buffer.load.i32(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.cmp.i8(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.i16(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.i32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.f32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x8(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x16(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x32(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.finite.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i8(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i16(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.f32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.pow.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.exp.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.log.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rsqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cos.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sin.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.tanh.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.atan2.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i8(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i16(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.f32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.floor.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.ceil.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.round.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.fft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.ifft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.irfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.conv.f32f32.f32(%input : !vm.ref<!vmla.buffer>, %input_shape : i32 ..., %filter : !vm.ref<!vmla.buffer>, %filter_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_strides : i32 ..., %padding : i32 ..., %lhs_dilation : i32 ..., %rhs_dilation : i32 ..., %feature_group_count : i32, %batch_group_count : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i32i32.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i8i8.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i8 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i8 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i16i16.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i16 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i16 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.and.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.or.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
      %c5 = vm.const.i32 5 : i32
      %c4 = vm.const.i32 4 : i32
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
      %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
      %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
      %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
      %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %4 = vm.mul.i32 %3, %c4 : i32
      %5 = vm.mul.i32 %4, %2 : i32
      %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %6 = vm.mul.i32 %1, %c4 : i32
      %7 = vm.mul.i32 %6, %0 : i32
      %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %8 = vm.mul.i32 %2, %c4 : i32
      %9 = vm.mul.i32 %8, %3 : i32
      %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %10 = vm.mul.i32 %2, %c4 : i32
      %11 = vm.mul.i32 %10, %1 : i32
      %ref_4 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %12 = vm.mul.i32 %1, %c4 : i32
      %13 = vm.mul.i32 %12, %2 : i32
      %ref_5 = vm.call @vmla.buffer.alloc(%13) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %14 = vm.mul.i32 %6, %2 : i32
      vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %14) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
      vm.return
    }
    vm.export @dot_ex_dispatch_0
  }
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
module  {
  vm.module @module {
    vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.const(%value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.clone(%src : !vm.ref<!vmla.buffer>) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.byte_length(%value : !vm.ref<!vmla.buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.buffer.fill(%value : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.buffer.load.i32(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.cmp.i8(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.i16(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.i32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cmp.f32(%predicate : i32, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x8(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x16(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.select.x32(%cond : !vm.ref<!vmla.buffer>, %lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.finite.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.copy.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %src_indices : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dst_indices : i32 ..., %lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reverse.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dimensions : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pad.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %value : !vm.ref<!vmla.buffer>, %value_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %edge_padding_low : i32 ..., %edge_padding_high : i32 ..., %interior_padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.gather.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %dim : i32, %batch_dims : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.scatter.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %indices : !vm.ref<!vmla.buffer>, %indices_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.broadcast.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i8(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i16(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.i32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.iota.f32(%dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.tile.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.not.x32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.and.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.or.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.xor.broadcast.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : i32, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shl.x32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.shr.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.add.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sub.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.abs.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.neg.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.mul.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.div.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.u32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rem.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.pow.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.exp.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.log.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rsqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sqrt.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.cos.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sin.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.tanh.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.atan2.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.min.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i8(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i16(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.i32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.max.f32(%lhs : !vm.ref<!vmla.buffer>, %rhs : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i8(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i16(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.i32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.clamp.f32(%min : !vm.ref<!vmla.buffer>, %value : !vm.ref<!vmla.buffer>, %max : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.floor.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.ceil.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.round.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.sort.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.fft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.ifft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.rfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>, %imag_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.irfft.f32(%real_src : !vm.ref<!vmla.buffer>, %real_src_shape : i32 ..., %imag_src : !vm.ref<!vmla.buffer>, %imag_src_shape : i32 ..., %real_dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i8.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i16.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.i32.f32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i8(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i16(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.convert.f32.i32(%src : !vm.ref<!vmla.buffer>, %dst : !vm.ref<!vmla.buffer>) attributes {sym_visibility = "private"}
    vm.import @vmla.conv.f32f32.f32(%input : !vm.ref<!vmla.buffer>, %input_shape : i32 ..., %filter : !vm.ref<!vmla.buffer>, %filter_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_strides : i32 ..., %padding : i32 ..., %lhs_dilation : i32 ..., %rhs_dilation : i32 ..., %feature_group_count : i32, %batch_group_count : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i32i32.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i8i8.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i8 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i8 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.i16i16.i32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i16 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i16 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.and.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.reduce.or.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dimension : i32, %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.sum.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.min.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i8(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i16(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.i32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.pooling.max.f32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %init : !vm.ref<!vmla.buffer>, %init_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ..., %window_dimensions : i32 ..., %window_strides : i32 ..., %padding : i32 ...) attributes {sym_visibility = "private"}
    vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
      %c5 = vm.const.i32 5 : i32
      %c4 = vm.const.i32 4 : i32
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
      %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
      %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
      %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
      %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %4 = vm.mul.i32 %3, %c4 : i32
      %5 = vm.mul.i32 %4, %2 : i32
      %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %6 = vm.mul.i32 %1, %c4 : i32
      %7 = vm.mul.i32 %6, %0 : i32
      %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %8 = vm.mul.i32 %2, %c4 : i32
      %9 = vm.mul.i32 %8, %3 : i32
      %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %10 = vm.mul.i32 %8, %1 : i32
      %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %11 = vm.mul.i32 %6, %2 : i32
      %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
      vm.return
    }
    vm.export @dot_ex_dispatch_0
  }
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  vm.module @module {
    vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
    vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
    vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
      %c5 = vm.const.i32 5 : i32
      %c4 = vm.const.i32 4 : i32
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
      %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
      %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
      %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
      %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %4 = vm.mul.i32 %3, %c4 : i32
      %5 = vm.mul.i32 %4, %2 : i32
      %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      %6 = vm.mul.i32 %1, %c4 : i32
      %7 = vm.mul.i32 %6, %0 : i32
      %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
      %8 = vm.mul.i32 %2, %c4 : i32
      %9 = vm.mul.i32 %8, %3 : i32
      %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %10 = vm.mul.i32 %8, %1 : i32
      %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %11 = vm.mul.i32 %6, %2 : i32
      %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
      vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
      %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
      vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
      vm.return
    }
    vm.export @dot_ex_dispatch_0
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::SinkDefiningOpsPass

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c5 = vm.const.i32 5 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c4 = vm.const.i32 4 : i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c3 = vm.const.i32 3 : i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %c2 = vm.const.i32 2 : i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %zero = vm.const.i32.zero : i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %c1 = vm.const.i32 1 : i32
    %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %8, %1 : i32
    %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %11 = vm.mul.i32 %6, %2 : i32
    %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass

{% raw %}
```
hal.executable.target @vmla, filter="vmla" {
  hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
  module  {
    vm.module @module {
      vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
      vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
      vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
      vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
      vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
      vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
      vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
      vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
        %c5 = vm.const.i32 5 : i32
        %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
        %c4 = vm.const.i32 4 : i32
        %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
        %c3 = vm.const.i32 3 : i32
        %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
        %c2 = vm.const.i32 2 : i32
        %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
        %zero = vm.const.i32.zero : i32
        %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
        %4 = vm.mul.i32 %3, %c4 : i32
        %5 = vm.mul.i32 %4, %2 : i32
        %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
        %c1 = vm.const.i32 1 : i32
        %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
        %6 = vm.mul.i32 %1, %c4 : i32
        %7 = vm.mul.i32 %6, %0 : i32
        %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
        %8 = vm.mul.i32 %2, %c4 : i32
        %9 = vm.mul.i32 %8, %3 : i32
        %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
        vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
        %10 = vm.mul.i32 %8, %1 : i32
        %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
        vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
        %11 = vm.mul.i32 %6, %2 : i32
        %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
        vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
        %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
        vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
        vm.return
      }
      vm.export @dot_ex_dispatch_0
    }
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::{anonymous}::ConvertToHALPass

{% raw %}
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c4 = vm.const.i32 4 : i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c3 = vm.const.i32 3 : i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c2 = vm.const.i32 2 : i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %zero = vm.const.i32.zero : i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %c1 = vm.const.i32 1 : i32
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: !shapex.ranked_shape<[?,?]>, %arg2: !hal.buffer, %arg3: !shapex.ranked_shape<[?,?]>) -> (!hal.buffer, !shapex.ranked_shape<[?,?]>) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %0 = shapex.ranked_dim %arg1[1] : !shapex.ranked_shape<[?,?]> -> index
    %1 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %2 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %3 = shapex.ranked_dim %arg3[0] : !shapex.ranked_shape<[?,?]> -> index
    %4 = shapex.ranked_dim %arg1[0] : !shapex.ranked_shape<[?,?]> -> index
    %5 = shapex.ranked_dim %arg3[1] : !shapex.ranked_shape<[?,?]> -> index
    %6 = muli %4, %5 : index
    %7 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %8 = shapex.make_ranked_shape %3, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %9 = shapex.ranked_dim %8[0] : !shapex.ranked_shape<[?,?]> -> index
    %10 = shapex.ranked_dim %8[1] : !shapex.ranked_shape<[?,?]> -> index
    %c50331680_i32 = constant 50331680 : i32
    %sz = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%9, %10]) type(%c50331680_i32) : index
    %11 = shapex.make_ranked_shape %1, %0 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %12 = shapex.ranked_dim %11[0] : !shapex.ranked_shape<[?,?]> -> index
    %13 = shapex.ranked_dim %11[1] : !shapex.ranked_shape<[?,?]> -> index
    %sz_0 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%12, %13]) type(%c50331680_i32) : index
    %14 = shapex.make_ranked_shape %4, %5 : (index, index) -> !shapex.ranked_shape<[?,?]>
    %15 = shapex.ranked_dim %14[0] : !shapex.ranked_shape<[?,?]> -> index
    %16 = shapex.ranked_dim %14[1] : !shapex.ranked_shape<[?,?]> -> index
    %sz_1 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%15, %16]) type(%c50331680_i32) : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%sz_1}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    %17 = index_cast %4 : index to i32
    %18 = index_cast %5 : index to i32
    %19 = index_cast %3 : index to i32
    %20 = index_cast %2 : index to i32
    %21 = index_cast %1 : index to i32
    %22 = index_cast %0 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%17, %18, %19, %20, %21, %22]) : i32, i32, i32, i32, i32, i32
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0_2 = constant 0 : index
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0_2] bindings([
      %c0 = (%arg2 : !hal.buffer)[%c0, %sz], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %sz_0], 
      %c2 = (%buffer : !hal.buffer)[%c0, %sz_1]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg4 = %cmd : !hal.command_buffer, %arg5 = %6 : index) {
      %c1_3 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg4 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_3, %c1_3, %c1_3])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %7 : !hal.buffer, !shapex.ranked_shape<[?,?]>
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ExpandFunctionRankedShapeDimsPass

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %0 = shapex.make_ranked_shape %arg1, %arg2 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %1 = shapex.make_ranked_shape %arg4, %arg5 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %2 = shapex.ranked_dim %0[1] : !shapex.ranked_shape<[?,?]> -> index
  %3 = shapex.ranked_dim %0[0] : !shapex.ranked_shape<[?,?]> -> index
  %4 = shapex.ranked_dim %1[1] : !shapex.ranked_shape<[?,?]> -> index
  %5 = shapex.ranked_dim %1[0] : !shapex.ranked_shape<[?,?]> -> index
  %6 = shapex.ranked_dim %0[0] : !shapex.ranked_shape<[?,?]> -> index
  %7 = shapex.ranked_dim %1[1] : !shapex.ranked_shape<[?,?]> -> index
  %8 = muli %6, %7 : index
  %9 = shapex.make_ranked_shape %6, %7 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %10 = shapex.make_ranked_shape %5, %4 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %11 = shapex.ranked_dim %10[0] : !shapex.ranked_shape<[?,?]> -> index
  %12 = shapex.ranked_dim %10[1] : !shapex.ranked_shape<[?,?]> -> index
  %c50331680_i32 = constant 50331680 : i32
  %sz = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%11, %12]) type(%c50331680_i32) : index
  %13 = shapex.make_ranked_shape %3, %2 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %14 = shapex.ranked_dim %13[0] : !shapex.ranked_shape<[?,?]> -> index
  %15 = shapex.ranked_dim %13[1] : !shapex.ranked_shape<[?,?]> -> index
  %sz_0 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%14, %15]) type(%c50331680_i32) : index
  %16 = shapex.make_ranked_shape %6, %7 : (index, index) -> !shapex.ranked_shape<[?,?]>
  %17 = shapex.ranked_dim %16[0] : !shapex.ranked_shape<[?,?]> -> index
  %18 = shapex.ranked_dim %16[1] : !shapex.ranked_shape<[?,?]> -> index
  %sz_1 = hal.allocator.compute_size<%allocator : !hal.allocator> shape([%17, %18]) type(%c50331680_i32) : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%sz_1}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %19 = index_cast %6 : index to i32
  %20 = index_cast %7 : index to i32
  %21 = index_cast %5 : index to i32
  %22 = index_cast %4 : index to i32
  %23 = index_cast %3 : index to i32
  %24 = index_cast %2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%19, %20, %21, %22, %23, %24]) : i32, i32, i32, i32, i32, i32
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0_2 = constant 0 : index
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0_2] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %sz], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %sz_0], 
    %c2 = (%buffer : !hal.buffer)[%c0, %sz_1]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %8 : index) {
    %c1_3 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg6 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_3, %c1_3, %c1_3])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  %25 = shapex.ranked_dim %9[0] : !shapex.ranked_shape<[?,?]> -> index
  %26 = shapex.ranked_dim %9[1] : !shapex.ranked_shape<[?,?]> -> index
  return %buffer, %25, %26 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %0 = muli %arg1, %arg5 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %1 = muli %arg4, %c4 : index
  %2 = muli %1, %arg5 : index
  %3 = muli %arg1, %c4 : index
  %4 = muli %3, %arg2 : index
  %5 = muli %arg1, %c4 : index
  %6 = muli %5, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%6}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %7 = index_cast %arg1 : index to i32
  %8 = index_cast %arg5 : index to i32
  %9 = index_cast %arg4 : index to i32
  %10 = index_cast %arg5 : index to i32
  %11 = index_cast %arg1 : index to i32
  %12 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%7, %8, %9, %10, %11, %12]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
    %c2 = (%buffer : !hal.buffer)[%c0, %6]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
    %c1_0 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg6 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_0, %c1_0, %c1_0])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %0 = muli %arg1, %arg5 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %1 = muli %arg4, %c4 : index
  %2 = muli %1, %arg5 : index
  %3 = muli %arg1, %c4 : index
  %4 = muli %3, %arg2 : index
  %5 = muli %3, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
    %c2 = (%buffer : !hal.buffer)[%c0, %5]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
    %c1_0 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg6 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_0, %c1_0, %c1_0])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::PackAllocationsPass

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {iree.module.export, iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %0 = muli %arg1, %arg5 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %1 = muli %arg4, %c4 : index
  %2 = muli %1, %arg5 : index
  %3 = muli %arg1, %c4 : index
  %4 = muli %3, %arg2 : index
  %5 = muli %3, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
    %c2 = (%buffer : !hal.buffer)[%c0, %5]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
    %c1_0 = constant 1 : index
    hal.command_buffer.dispatch.symbol<%arg6 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_0, %c1_0, %c1_0])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::{anonymous}::PublicABIGenerationPass

{% raw %}
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c4 = vm.const.i32 4 : i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c3 = vm.const.i32 3 : i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c2 = vm.const.i32 2 : i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %zero = vm.const.i32.zero : i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %c1 = vm.const.i32 1 : i32
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %0 = muli %arg1, %arg5 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %1 = muli %arg4, %c4 : index
    %2 = muli %1, %arg5 : index
    %3 = muli %arg1, %c4 : index
    %4 = muli %3, %arg2 : index
    %5 = muli %3, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    %6 = index_cast %arg1 : index to i32
    %7 = index_cast %arg5 : index to i32
    %8 = index_cast %arg4 : index to i32
    %9 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
      %c2 = (%buffer : !hal.buffer)[%c0, %5]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
      %c1_0 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg6 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_0, %c1_0, %c1_0])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %c50331680_i32 = constant 50331680 : i32
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::LinkExecutablesPass

{% raw %}
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c4 = vm.const.i32 4 : i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c3 = vm.const.i32 3 : i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %c2 = vm.const.i32 2 : i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %zero = vm.const.i32.zero : i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %c1 = vm.const.i32 1 : i32
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %0 = muli %arg1, %arg5 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %1 = muli %arg4, %c4 : index
    %2 = muli %1, %arg5 : index
    %3 = muli %arg1, %c4 : index
    %4 = muli %3, %arg2 : index
    %5 = muli %3, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    %6 = index_cast %arg1 : index to i32
    %7 = index_cast %arg5 : index to i32
    %8 = index_cast %arg4 : index to i32
    %9 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
      %c2 = (%buffer : !hal.buffer)[%c0, %5]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
      %c1_0 = constant 1 : index
      hal.command_buffer.dispatch.symbol<%arg6 : !hal.command_buffer> target(@dot_ex_dispatch_0::@vmla::@dot_ex_dispatch_0) workgroups([%c1_0, %c1_0, %c1_0])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %c50331680_i32 = constant 50331680 : i32
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::ResolveEntryPointOrdinalsPass

{% raw %}
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %c4 = vm.const.i32 4 : i32
            %c3 = vm.const.i32 3 : i32
            %c2 = vm.const.i32 2 : i32
            %zero = vm.const.i32.zero : i32
            %c1 = vm.const.i32 1 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %0 = muli %arg1, %arg5 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %1 = muli %arg4, %c4 : index
    %2 = muli %1, %arg5 : index
    %3 = muli %arg1, %c4 : index
    %4 = muli %3, %arg2 : index
    %5 = muli %3, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
    %6 = index_cast %arg1 : index to i32
    %7 = index_cast %arg5 : index to i32
    %8 = index_cast %arg4 : index to i32
    %9 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
      %c2 = (%buffer : !hal.buffer)[%c0, %5]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
      %c1_0 = constant 1 : index
      %10 = hal.command_buffer.device<%arg6 : !hal.command_buffer> : !hal.device
      %exe = hal.executable.lookup device(%10 : !hal.device) executable(@dot_ex_dispatch_0) : !hal.executable
      hal.command_buffer.dispatch<%arg6 : !hal.command_buffer> target(%exe : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %0 = muli %arg1, %arg5 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %1 = muli %arg4, %c4 : index
  %2 = muli %1, %arg5 : index
  %3 = muli %arg1, %c4 : index
  %4 = muli %3, %arg2 : index
  %5 = muli %3, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
    %c2 = (%buffer : !hal.buffer)[%c0, %5]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
    %c1_0 = constant 1 : index
    %10 = hal.command_buffer.device<%arg6 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%10 : !hal.device) executable(@dot_ex_dispatch_0) : !hal.executable
    hal.command_buffer.dispatch<%arg6 : !hal.command_buffer> target(%exe : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %0 = muli %arg1, %arg5 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %1 = muli %arg4, %c4 : index
  %2 = muli %1, %arg5 : index
  %3 = muli %arg1, %c4 : index
  %4 = muli %3, %arg2 : index
  %5 = muli %3, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %executable_layout = hal.executable_layout.lookup device(%device : !hal.device) push_constants(6) layouts([[#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]]) : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%executable_layout : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
    %c2 = (%buffer : !hal.buffer)[%c0, %5]
  ])
  hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
    %c1_0 = constant 1 : index
    %10 = hal.command_buffer.device<%arg6 : !hal.command_buffer> : !hal.device
    %exe = hal.executable.lookup device(%10 : !hal.device) executable(@dot_ex_dispatch_0) : !hal.executable
    hal.command_buffer.dispatch<%arg6 : !hal.command_buffer> target(%exe : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
    hal.return
  }
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeResourceCachesPass

{% raw %}
```
module  {
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.switch<%device : !hal.device> -> !hal.executable
    #hal.device.match.id<"vmla">(%arg0 = %device : !hal.device) {
      %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
      %exe = hal.executable.create device(%arg0 : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
      hal.return %exe : !hal.executable
    },
    #hal.match.always() {
      %1 = iree.null : !hal.executable
      hal.return %1 : !hal.executable
    }
    return %0 : !hal.executable
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %c4 = vm.const.i32 4 : i32
            %c3 = vm.const.i32 3 : i32
            %c2 = vm.const.i32 2 : i32
            %zero = vm.const.i32.zero : i32
            %c1 = vm.const.i32 1 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %0 = muli %arg1, %arg5 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %1 = muli %arg4, %c4 : index
    %2 = muli %1, %arg5 : index
    %3 = muli %arg1, %c4 : index
    %4 = muli %3, %arg2 : index
    %5 = muli %3, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %7 = index_cast %arg1 : index to i32
    %8 = index_cast %arg5 : index to i32
    %9 = index_cast %arg4 : index to i32
    %10 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout) offset(0) values([%7, %8, %9, %8, %7, %10]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
      %c2 = (%buffer : !hal.buffer)[%c0, %5]
    ])
    hal.device.switch<%device : !hal.device>
    #hal.device.match.id<"vmla">(%arg6 = %cmd : !hal.command_buffer, %arg7 = %0 : index) {
      %c1_0 = constant 1 : index
      %11 = hal.command_buffer.device<%arg6 : !hal.command_buffer> : !hal.device
      %12 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
      hal.command_buffer.dispatch<%arg6 : !hal.command_buffer> target(%12 : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
      hal.return
    }
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass

{% raw %}
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass

{% raw %}
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass

{% raw %}
```
func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
  br ^bb5(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %true = constant true
  cond_br %true, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  %2 = iree.null : !hal.executable
  br ^bb5(%2 : !hal.executable)
^bb4:  // pred: ^bb2
  iree.unreachable "device not supported in the compiled configuration"
^bb5(%3: !hal.executable):  // 2 preds: ^bb1, ^bb3
  return %3 : !hal.executable
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %0 = muli %arg1, %arg5 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %1 = muli %arg4, %c4 : index
  %2 = muli %1, %arg5 : index
  %3 = muli %arg1, %c4 : index
  %4 = muli %3, %arg2 : index
  %5 = muli %3, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %7 = index_cast %arg1 : index to i32
  %8 = index_cast %arg5 : index to i32
  %9 = index_cast %arg4 : index to i32
  %10 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout) offset(0) values([%7, %8, %9, %8, %7, %10]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
    %c2 = (%buffer : !hal.buffer)[%c0, %5]
  ])
  %11 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %c1_0 = constant 1 : index
  %12 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
  %13 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%13 : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
  br ^bb3
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
^bb3:  // pred: ^bb1
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After ConvertAffineToStandard

{% raw %}
```
module  {
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
    br ^bb5(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %true = constant true
    cond_br %true, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %2 = iree.null : !hal.executable
    br ^bb5(%2 : !hal.executable)
  ^bb4:  // pred: ^bb2
    iree.unreachable "device not supported in the compiled configuration"
  ^bb5(%3: !hal.executable):  // 2 preds: ^bb1, ^bb3
    return %3 : !hal.executable
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %c4 = vm.const.i32 4 : i32
            %c3 = vm.const.i32 3 : i32
            %c2 = vm.const.i32 2 : i32
            %zero = vm.const.i32.zero : i32
            %c1 = vm.const.i32 1 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %0 = muli %arg1, %arg5 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %1 = muli %arg4, %c4 : index
    %2 = muli %1, %arg5 : index
    %3 = muli %arg1, %c4 : index
    %4 = muli %3, %arg2 : index
    %5 = muli %3, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %7 = index_cast %arg1 : index to i32
    %8 = index_cast %arg5 : index to i32
    %9 = index_cast %arg4 : index to i32
    %10 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout) offset(0) values([%7, %8, %9, %8, %7, %10]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
      %c2 = (%buffer : !hal.buffer)[%c0, %5]
    ])
    %11 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
    cond_br %11, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %c1_0 = constant 1 : index
    %12 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %13 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%13 : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  ^bb3:  // pred: ^bb1
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::MemoizeDeviceQueriesPass

{% raw %}
```
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
    br ^bb5(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %true = constant true
    cond_br %true, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %2 = iree.null : !hal.executable
    br ^bb5(%2 : !hal.executable)
  ^bb4:  // pred: ^bb2
    iree.unreachable "device not supported in the compiled configuration"
  ^bb5(%3: !hal.executable):  // 2 preds: ^bb1, ^bb3
    return %3 : !hal.executable
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vmla, filter="vmla" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : index, signature = (index, index, tensor<?x?xf32>, index, index, tensor<?x?xf32>, index, index) -> tensor<?x?xf32>}
      module  {
        vm.module @module {
          vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
          vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
          vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
          vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
            %c5 = vm.const.i32 5 : i32
            %c4 = vm.const.i32 4 : i32
            %c3 = vm.const.i32 3 : i32
            %c2 = vm.const.i32 2 : i32
            %zero = vm.const.i32.zero : i32
            %c1 = vm.const.i32 1 : i32
            %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
            %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
            %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
            %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
            %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %4 = vm.mul.i32 %3, %c4 : i32
            %5 = vm.mul.i32 %4, %2 : i32
            %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            %6 = vm.mul.i32 %1, %c4 : i32
            %7 = vm.mul.i32 %6, %0 : i32
            %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
            %8 = vm.mul.i32 %2, %c4 : i32
            %9 = vm.mul.i32 %8, %3 : i32
            %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %10 = vm.mul.i32 %8, %1 : i32
            %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %11 = vm.mul.i32 %6, %2 : i32
            %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
            vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
            %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
            vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
            vm.return
          }
          vm.export @dot_ex_dispatch_0
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %0 = muli %arg1, %arg5 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %1 = muli %arg4, %c4 : index
    %2 = muli %1, %arg5 : index
    %3 = muli %arg1, %c4 : index
    %4 = muli %3, %arg2 : index
    %5 = muli %3, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%5}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %6 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %7 = index_cast %arg1 : index to i32
    %8 = index_cast %arg5 : index to i32
    %9 = index_cast %arg4 : index to i32
    %10 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout) offset(0) values([%7, %8, %9, %8, %7, %10]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%6 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %2], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %4], 
      %c2 = (%buffer : !hal.buffer)[%c0, %5]
    ])
    %11 = hal.variable.load @_device_match_id_0 : i1
    cond_br %11, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %c1_0 = constant 1 : index
    %12 = hal.command_buffer.device<%cmd : !hal.command_buffer> : !hal.device
    %13 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%13 : !hal.executable)[0] workgroups([%c1_0, %c1_0, %c1_0])
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  ^bb3:  // pred: ^bb1
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
  return %0 : i1
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
  return %0 : i1
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
  return %0 : i1
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %2 = iree.null : !hal.executable
  br ^bb3(%2 : !hal.executable)
^bb3(%3: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %3 : !hal.executable
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %2 = iree.null : !hal.executable
  br ^bb3(%2 : !hal.executable)
^bb3(%3: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %3 : !hal.executable
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %2 = iree.null : !hal.executable
  br ^bb3(%2 : !hal.executable)
^bb3(%3: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %3 : !hal.executable
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
  %c5 = vm.const.i32 5 : i32
  %c4 = vm.const.i32 4 : i32
  %c3 = vm.const.i32 3 : i32
  %c2 = vm.const.i32 2 : i32
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
  %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
  %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
  %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
  %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
  %4 = vm.mul.i32 %3, %c4 : i32
  %5 = vm.mul.i32 %4, %2 : i32
  %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
  %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
  %6 = vm.mul.i32 %1, %c4 : i32
  %7 = vm.mul.i32 %6, %0 : i32
  %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
  %8 = vm.mul.i32 %2, %c4 : i32
  %9 = vm.mul.i32 %8, %3 : i32
  %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
  vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
  %10 = vm.mul.i32 %8, %1 : i32
  %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
  vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
  %11 = vm.mul.i32 %6, %2 : i32
  %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
  vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
  %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
  vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
  vm.return
}

```
{% endraw %}

### IR Dump After Inliner

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c5 = vm.const.i32 5 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %8, %1 : i32
    %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %11 = vm.mul.i32 %6, %2 : i32
    %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c5 = vm.const.i32 5 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %8, %1 : i32
    %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %11 = vm.mul.i32 %6, %2 : i32
    %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c5 = vm.const.i32 5 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %8, %1 : i32
    %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %11 = vm.mul.i32 %6, %2 : i32
    %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::DropCompilerHintsPass

{% raw %}
```
vm.module @module {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) {
    %c5 = vm.const.i32 5 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %8, %1 : i32
    %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %11 = vm.mul.i32 %6, %2 : i32
    %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::OrdinalAllocationPass

{% raw %}
```
vm.module @module attributes {ordinal_counts = #vm.ordinal_counts<import_funcs = 7, export_funcs = 1, internal_funcs = 1, global_bytes = 0, global_refs = 0, rodatas = 0, rwdatas = 0>} {
  vm.import @vmla.interface.const(%interface : !vm.ref<!vmla.interface>, %offset : i32) -> i32 attributes {nosideeffects, ordinal = 0 : i32, sym_visibility = "private"}
  vm.import @vmla.interface.binding(%interface : !vm.ref<!vmla.interface>, %set : i32, %binding : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, ordinal = 1 : i32, sym_visibility = "private"}
  vm.import @vmla.buffer.alloc(%byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, ordinal = 2 : i32, sym_visibility = "private"}
  vm.import @vmla.buffer.view(%src : !vm.ref<!vmla.buffer>, %byte_offset : i32, %byte_length : i32) -> !vm.ref<!vmla.buffer> attributes {nosideeffects, ordinal = 3 : i32, sym_visibility = "private"}
  vm.import @vmla.buffer.copy(%src : !vm.ref<!vmla.buffer>, %src_byte_offset : i32, %dst : !vm.ref<!vmla.buffer>, %dst_byte_offset : i32, %byte_length : i32) attributes {ordinal = 4 : i32, sym_visibility = "private"}
  vm.import @vmla.transpose.x32(%src : !vm.ref<!vmla.buffer>, %src_shape : i32 ..., %permutation : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {ordinal = 5 : i32, sym_visibility = "private"}
  vm.import @vmla.batch.matmul.f32f32.f32(%lhs : !vm.ref<!vmla.buffer>, %lhs_shape : i32 ..., %rhs : !vm.ref<!vmla.buffer>, %rhs_shape : i32 ..., %dst : !vm.ref<!vmla.buffer>, %dst_shape : i32 ...) attributes {ordinal = 6 : i32, sym_visibility = "private"}
  vm.func @dot_ex_dispatch_0(%arg0: !vm.ref<!vmla.interface>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {ordinal = 0 : i32} {
    %c5 = vm.const.i32 5 : i32
    %c4 = vm.const.i32 4 : i32
    %c3 = vm.const.i32 3 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %0 = vm.call @vmla.interface.const(%arg0, %c5) : (!vm.ref<!vmla.interface>, i32) -> i32
    %1 = vm.call @vmla.interface.const(%arg0, %c4) : (!vm.ref<!vmla.interface>, i32) -> i32
    %2 = vm.call @vmla.interface.const(%arg0, %c3) : (!vm.ref<!vmla.interface>, i32) -> i32
    %3 = vm.call @vmla.interface.const(%arg0, %c2) : (!vm.ref<!vmla.interface>, i32) -> i32
    %ref = vm.call @vmla.interface.binding(%arg0, %zero, %zero) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %4 = vm.mul.i32 %3, %c4 : i32
    %5 = vm.mul.i32 %4, %2 : i32
    %ref_0 = vm.call @vmla.buffer.view(%ref, %zero, %5) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %ref_1 = vm.call @vmla.interface.binding(%arg0, %zero, %c1) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    %6 = vm.mul.i32 %1, %c4 : i32
    %7 = vm.mul.i32 %6, %0 : i32
    %ref_2 = vm.call @vmla.buffer.view(%ref_1, %zero, %7) : (!vm.ref<!vmla.buffer>, i32, i32) -> !vm.ref<!vmla.buffer>
    %8 = vm.mul.i32 %2, %c4 : i32
    %9 = vm.mul.i32 %8, %3 : i32
    %ref_3 = vm.call @vmla.buffer.alloc(%9) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_0, [%3, %2], [%c1, %zero], %ref_3, [%2, %3]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %10 = vm.mul.i32 %8, %1 : i32
    %ref_4 = vm.call @vmla.buffer.alloc(%10) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.batch.matmul.f32f32.f32(%ref_2, [%c1, %1, %0], %ref_3, [%c1, %2, %3], %ref_4, [%c1, %2, %1]) : (!vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %11 = vm.mul.i32 %6, %2 : i32
    %ref_5 = vm.call @vmla.buffer.alloc(%11) : (i32) -> !vm.ref<!vmla.buffer>
    vm.call.variadic @vmla.transpose.x32(%ref_4, [%c1, %2, %1], [%zero, %c2, %c1], %ref_5, [%c1, %1, %2]) : (!vm.ref<!vmla.buffer>, i32 ..., i32 ..., !vm.ref<!vmla.buffer>, i32 ...)
    %ref_6 = vm.call @vmla.interface.binding(%arg0, %zero, %c2) : (!vm.ref<!vmla.interface>, i32, i32) -> !vm.ref<!vmla.buffer>
    vm.call @vmla.buffer.copy(%ref_5, %zero, %ref_6, %zero, %11) : (!vm.ref<!vmla.buffer>, i32, !vm.ref<!vmla.buffer>, i32, i32) -> ()
    vm.return
  }
  vm.export @dot_ex_dispatch_0 attributes {ordinal = 0 : i32}
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::SerializeExecutablesPass

{% raw %}
```
hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
  hal.interface @legacy_io attributes {push_constants = 6 : index} {
    hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
  hal.executable.binary @vmla attributes {data = opaque<"_", "0xDEADBEEF"> : vector<1542xi8>, format = "VMLA"} {
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %0 = muli %arg4, %c4 : index
  %1 = muli %0, %arg5 : index
  %2 = muli %arg1, %c4 : index
  %3 = muli %2, %arg2 : index
  %4 = muli %2, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%4}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %5 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %1], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %3], 
    %c2 = (%buffer : !hal.buffer)[%c0, %4]
  ])
  %10 = hal.variable.load @_device_match_id_0 : i1
  cond_br %10, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %11 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[0] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %0 = muli %arg4, %c4 : index
  %1 = muli %0, %arg5 : index
  %2 = muli %arg1, %c4 : index
  %3 = muli %2, %arg2 : index
  %4 = muli %2, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%4}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %5 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %1], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %3], 
    %c2 = (%buffer : !hal.buffer)[%c0, %4]
  ])
  %10 = hal.variable.load @_device_match_id_0 : i1
  cond_br %10, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %11 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[0] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %0 = muli %arg4, %c4 : index
  %1 = muli %0, %arg5 : index
  %2 = muli %arg1, %c4 : index
  %3 = muli %2, %arg2 : index
  %4 = muli %2, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%4}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %5 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %1], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %3], 
    %c2 = (%buffer : !hal.buffer)[%c0, %4]
  ])
  %10 = hal.variable.load @_device_match_id_0 : i1
  cond_br %10, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %11 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[0] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::HAL::CSEVariableLoadsPass

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %2 = iree.null : !hal.executable
    br ^bb3(%2 : !hal.executable)
  ^bb3(%3: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %3 : !hal.executable
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @vmla attributes {data = opaque<"_", "0xDEADBEEF"> : vector<1542xi8>, format = "VMLA"} {
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %0 = muli %arg4, %c4 : index
    %1 = muli %0, %arg5 : index
    %2 = muli %arg1, %c4 : index
    %3 = muli %2, %arg2 : index
    %4 = muli %2, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%4}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %5 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %6 = index_cast %arg1 : index to i32
    %7 = index_cast %arg5 : index to i32
    %8 = index_cast %arg4 : index to i32
    %9 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %1], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %3], 
      %c2 = (%buffer : !hal.buffer)[%c0, %4]
    ])
    %10 = hal.variable.load @_device_match_id_0 : i1
    cond_br %10, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %11 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[0] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_device_match_id_0_initializer() -> i1 {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
  return %0 : i1
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %device = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %device = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
  %device = hal.ex.shared_device : !hal.device
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
  br ^bb3(%exe : !hal.executable)
^bb2:  // pred: ^bb0
  %2 = iree.null : !hal.executable
  br ^bb3(%2 : !hal.executable)
^bb3(%3: !hal.executable):  // 2 preds: ^bb1, ^bb2
  return %3 : !hal.executable
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
  %c4 = constant 4 : index
  %c2 = constant 2 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
  %0 = muli %arg4, %c4 : index
  %1 = muli %0, %arg5 : index
  %2 = muli %arg1, %c4 : index
  %3 = muli %2, %arg2 : index
  %4 = muli %2, %arg5 : index
  %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%4}
  %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
  hal.command_buffer.begin<%cmd : !hal.command_buffer>
  %5 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %6 = index_cast %arg1 : index to i32
  %7 = index_cast %arg5 : index to i32
  %8 = index_cast %arg4 : index to i32
  %9 = index_cast %arg2 : index to i32
  hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
  hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
    %c0 = (%arg3 : !hal.buffer)[%c0, %1], 
    %c1 = (%arg0 : !hal.buffer)[%c0, %3], 
    %c2 = (%buffer : !hal.buffer)[%c0, %4]
  ])
  %10 = hal.variable.load @_device_match_id_0 : i1
  cond_br %10, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %11 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[0] workgroups([%c1, %c1, %c1])
  hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
  hal.command_buffer.end<%cmd : !hal.command_buffer>
  hal.ex.submit_and_wait %device, %cmd
  return %buffer, %arg1, %arg5 : !hal.buffer, index, index
^bb2:  // pred: ^bb0
  iree.unreachable "device not supported in the compiled configuration"
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c50331680_i32 = constant 50331680 : i32
  %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %1 = hal.buffer_view.dim %arg2, 0 : index
  %2 = hal.buffer_view.dim %arg2, 1 : index
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %3 = hal.buffer_view.dim %arg3, 0 : index
  %4 = hal.buffer_view.dim %arg3, 1 : index
  %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
  %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
  hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
  return %view : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %device = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id<%device : !hal.device> pattern("vmla") : i1
    return %0 : i1
  }
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %device = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create device(%device : !hal.device) usage(PushOnly) bindings([#hal.descriptor_set_layout_binding<0, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<1, "StorageBuffer", R>, #hal.descriptor_set_layout_binding<2, "StorageBuffer", DW>]) : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %device = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create device(%device : !hal.device) push_constants(6) layouts([%0]) : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !hal.executable attributes {sym_visibility = "private"}
  func private @_executable_dot_ex_dispatch_0_initializer() -> !hal.executable {
    %device = hal.ex.shared_device : !hal.device
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %exe = hal.executable.create device(%device : !hal.device) target(@dot_ex_dispatch_0::@vmla) layouts([%1]) : !hal.executable
    br ^bb3(%exe : !hal.executable)
  ^bb2:  // pred: ^bb0
    %2 = iree.null : !hal.executable
    br ^bb3(%2 : !hal.executable)
  ^bb3(%3: !hal.executable):  // 2 preds: ^bb1, ^bb2
    return %3 : !hal.executable
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io attributes {push_constants = 6 : index} {
      hal.interface.binding @arg2, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg5, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary @vmla attributes {data = opaque<"_", "0xDEADBEEF"> : vector<1542xi8>, format = "VMLA"} {
    }
  }
  func @dot(%arg0: !hal.buffer, %arg1: index, %arg2: index, %arg3: !hal.buffer, %arg4: index, %arg5: index) -> (!hal.buffer, index, index) attributes {noinline} {
    %c4 = constant 4 : index
    %c2 = constant 2 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator<%device : !hal.device> : !hal.allocator
    %0 = muli %arg4, %c4 : index
    %1 = muli %0, %arg5 : index
    %2 = muli %arg1, %c4 : index
    %3 = muli %2, %arg2 : index
    %4 = muli %2, %arg5 : index
    %buffer = hal.allocator.allocate<%allocator : !hal.allocator> type("HostVisible|DeviceVisible|DeviceLocal") usage("Transfer|Mapping|Dispatch") : !hal.buffer{%4}
    %cmd = hal.command_buffer.create device(%device : !hal.device) mode(OneShot) categories("Transfer|Dispatch") : !hal.command_buffer
    hal.command_buffer.begin<%cmd : !hal.command_buffer>
    %5 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %6 = index_cast %arg1 : index to i32
    %7 = index_cast %arg5 : index to i32
    %8 = index_cast %arg4 : index to i32
    %9 = index_cast %arg2 : index to i32
    hal.command_buffer.push_constants<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout) offset(0) values([%6, %7, %8, %7, %6, %9]) : i32, i32, i32, i32, i32, i32
    hal.command_buffer.push_descriptor_set<%cmd : !hal.command_buffer> layout(%5 : !hal.executable_layout)[%c0] bindings([
      %c0 = (%arg3 : !hal.buffer)[%c0, %1], 
      %c1 = (%arg0 : !hal.buffer)[%c0, %3], 
      %c2 = (%buffer : !hal.buffer)[%c0, %4]
    ])
    %10 = hal.variable.load @_device_match_id_0 : i1
    cond_br %10, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %11 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    hal.command_buffer.dispatch<%cmd : !hal.command_buffer> target(%11 : !hal.executable)[0] workgroups([%c1, %c1, %c1])
    hal.command_buffer.execution_barrier<%cmd : !hal.command_buffer> source("Dispatch|CommandRetire") target("CommandIssue|Dispatch") flags("None")
    hal.command_buffer.end<%cmd : !hal.command_buffer>
    hal.ex.submit_and_wait %device, %cmd
    return %buffer, %arg1, %arg5 : !hal.buffer, index, index
  ^bb2:  // pred: ^bb0
    iree.unreachable "device not supported in the compiled configuration"
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c50331680_i32 = constant 50331680 : i32
    %0 = hal.semaphore.await<%arg0 : !hal.semaphore> until(%arg1) : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %1 = hal.buffer_view.dim %arg2, 0 : index
    %2 = hal.buffer_view.dim %arg2, 1 : index
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %3 = hal.buffer_view.dim %arg3, 0 : index
    %4 = hal.buffer_view.dim %arg3, 1 : index
    %5:3 = call @dot(%buffer, %1, %2, %buffer_0, %3, %4) : (!hal.buffer, index, index, !hal.buffer, index, index) -> (!hal.buffer, index, index)
    %view = hal.buffer_view.create %5#0, element_type = %c50331680_i32, shape = [%5#1, %5#2] : !hal.buffer -> !hal.buffer_view
    hal.semaphore.signal<%arg4 : !hal.semaphore> value(%arg5)
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %device = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create device(%device : !hal.device) initial(%c0) : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await<%semaphore : !hal.semaphore> until(%c1) : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::ConversionPass

{% raw %}
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
    vm.func private @_device_match_id_0_initializer() -> i32 {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.rodata.inline "_utf8_vmla_EC74E8E47AC10E22" {alignment = 1 : i64} : !vm.ref<!iree.byte_buffer> = dense<[118, 109, 108, 97]> : vector<4xi8>
      %0 = vm.call @hal.device.match.id(%ref, %ref_0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.return %0 : i32
    }
    vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
    vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c1_0 = vm.const.i32 1 : i32
      %c1_1 = vm.const.i32 1 : i32
      %c7_2 = vm.const.i32 7 : i32
      %c1_3 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7_4 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
    }
    vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
    vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c6 = vm.const.i32 6 : i32
      %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.return %ref_0 : !vm.ref<!hal.executable_layout>
    }
    vm.global.ref @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !vm.ref<!hal.executable>
    vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
    vm.func private @_executable_dot_ex_dispatch_0_initializer() -> !vm.ref<!hal.executable> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_0 = vm.rodata.inline "_utf8_vmla_BAEA374E0A067A05" {alignment = 1 : i64} : !vm.ref<!iree.byte_buffer> = dense<[86, 77, 76, 65]> : vector<4xi8>
      %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
      %ref_1 = vm.call.variadic @hal.executable.create(%ref, %ref_0, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_1 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.return %0 : !vm.ref<!hal.executable>
    }
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.mul.i32 %arg4, %c4 : i32
      %1 = vm.mul.i32 %0, %arg5 : i32
      %2 = vm.mul.i32 %arg1, %c4 : i32
      %3 = vm.mul.i32 %2, %arg2 : i32
      %4 = vm.mul.i32 %2, %arg5 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %c1_2 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %zero_4 = vm.const.i32.zero : i32
      vm.call.variadic @hal.command_buffer.push_constants(%ref_3, %_executable_layout_0, %zero_4, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %zero_5 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %zero_5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero_6 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero_6) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
    ^bb2:  // pred: ^bb0
      %c2_7 = vm.const.i32 2 : i32
      vm.fail %c2_7, "device not supported in the compiled configuration"
    }
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %zero = vm.const.i32.zero : i32
      %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %c1 = vm.const.i32 1 : i32
      %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %zero_1 = vm.const.i32.zero : i32
      %3 = vm.call @hal.buffer_view.dim(%arg3, %zero_1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %c1_2 = vm.const.i32 1 : i32
      %4 = vm.call @hal.buffer_view.dim(%arg3, %c1_2) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_3:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.ref<!iree.byte_buffer>, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.ref<!iree.byte_buffer>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
      %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::HoistInlinedRodataPass

{% raw %}
```
vm.module @module {
  vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
  vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
  vm.func private @_device_match_id_0_initializer() -> i32 {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.return %0 : i32
  }
  vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c6 = vm.const.i32 6 : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_dot_ex_dispatch_0 init(@_executable_dot_ex_dispatch_0_initializer) : !vm.ref<!hal.executable>
  vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
  vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
  vm.func private @_executable_dot_ex_dispatch_0_initializer() -> !vm.ref<!hal.executable> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
    %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
    %ref_0 = vm.call.variadic @hal.executable.create(%ref, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
    vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
  ^bb2:  // pred: ^bb0
    %null = vm.const.ref.zero : !vm.ref<!hal.executable>
    vm.br ^bb3(%null : !vm.ref<!hal.executable>)
  ^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
    vm.return %0 : !vm.ref<!hal.executable>
  }
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
    %c4 = vm.const.i32 4 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %0 = vm.mul.i32 %arg4, %c4 : i32
    %1 = vm.mul.i32 %0, %arg5 : i32
    %2 = vm.mul.i32 %arg1, %c4 : i32
    %3 = vm.mul.i32 %2, %arg2 : i32
    %4 = vm.mul.i32 %2, %arg5 : i32
    %c50 = vm.const.i32 50 : i32
    %c14 = vm.const.i32 14 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c1_2 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %zero_4 = vm.const.i32.zero : i32
    vm.call.variadic @hal.command_buffer.push_constants(%ref_3, %_executable_layout_0, %zero_4, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    %zero_5 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %zero_5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %zero_6 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero_6) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
  ^bb2:  // pred: ^bb0
    %c2_7 = vm.const.i32 2 : i32
    vm.fail %c2_7, "device not supported in the compiled configuration"
  }
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %c50331680 = vm.const.i32 50331680 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %zero = vm.const.i32.zero : i32
    %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %c1 = vm.const.i32 1 : i32
    %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %zero_1 = vm.const.i32.zero : i32
    %3 = vm.call @hal.buffer_view.dim(%arg3, %zero_1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %c1_2 = vm.const.i32 1 : i32
    %4 = vm.call @hal.buffer_view.dim(%arg3, %c1_2) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_3:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
    %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_4 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$async
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%key : !vm.ref<!iree.byte_buffer>, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.ref<!iree.byte_buffer>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::GlobalInitializationPass

{% raw %}
```
vm.module @module {
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
  vm.func private @_device_match_id_0_initializer() -> i32 {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.return %0 : i32
  }
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c6 = vm.const.i32 6 : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
  vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
  vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
  vm.func private @_executable_dot_ex_dispatch_0_initializer() -> !vm.ref<!hal.executable> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
    %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
    %ref_0 = vm.call.variadic @hal.executable.create(%ref, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
    vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
  ^bb2:  // pred: ^bb0
    %null = vm.const.ref.zero : !vm.ref<!hal.executable>
    vm.br ^bb3(%null : !vm.ref<!hal.executable>)
  ^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
    vm.return %0 : !vm.ref<!hal.executable>
  }
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
    %c4 = vm.const.i32 4 : i32
    %c2 = vm.const.i32 2 : i32
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %0 = vm.mul.i32 %arg4, %c4 : i32
    %1 = vm.mul.i32 %0, %arg5 : i32
    %2 = vm.mul.i32 %arg1, %c4 : i32
    %3 = vm.mul.i32 %2, %arg2 : i32
    %4 = vm.mul.i32 %2, %arg5 : i32
    %c50 = vm.const.i32 50 : i32
    %c14 = vm.const.i32 14 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c1_2 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %zero_4 = vm.const.i32.zero : i32
    vm.call.variadic @hal.command_buffer.push_constants(%ref_3, %_executable_layout_0, %zero_4, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    %zero_5 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %zero_5, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %zero_6 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, %zero_6) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
  ^bb2:  // pred: ^bb0
    %c2_7 = vm.const.i32 2 : i32
    vm.fail %c2_7, "device not supported in the compiled configuration"
  }
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %c50331680 = vm.const.i32 50331680 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %zero = vm.const.i32.zero : i32
    %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %c1 = vm.const.i32 1 : i32
    %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %zero_1 = vm.const.i32.zero : i32
    %3 = vm.call @hal.buffer_view.dim(%arg3, %zero_1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %c1_2 = vm.const.i32 1 : i32
    %4 = vm.call @hal.buffer_view.dim(%arg3, %c1_2) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_3:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
    %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_4 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$async
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%key : !vm.ref<!iree.byte_buffer>, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.ref<!iree.byte_buffer>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
  vm.func @__init() {
    %0 = vm.call @_device_match_id_0_initializer() : () -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_1 = vm.call @_executable_dot_ex_dispatch_0_initializer() : () -> !vm.ref<!hal.executable>
    vm.global.store.ref %ref_1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    vm.return
  }
  vm.export @__init
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @__init() {
  %0 = vm.call @_device_match_id_0_initializer() : () -> i32
  vm.global.store.i32 %0, @_device_match_id_0 : i32
  %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %ref_1 = vm.call @_executable_dot_ex_dispatch_0_initializer() : () -> !vm.ref<!hal.executable>
  vm.global.store.ref %ref_1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
  vm.return
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
  %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
  %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  vm.return %ref_1 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
  %c50331680 = vm.const.i32 50331680 : i32
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
  %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
  vm.return %ref_2 : !vm.ref<!hal.buffer_view>
^bb2(%5: i32):  // pred: ^bb0
  vm.fail %5, "semaphore wait failed"
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
  %c4 = vm.const.i32 4 : i32
  %c50 = vm.const.i32 50 : i32
  %c14 = vm.const.i32 14 : i32
  %c1 = vm.const.i32 1 : i32
  %c3 = vm.const.i32 3 : i32
  %c20 = vm.const.i32 20 : i32
  %c5 = vm.const.i32 5 : i32
  %zero = vm.const.i32.zero : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %0 = vm.mul.i32 %arg4, %c4 : i32
  %1 = vm.mul.i32 %0, %arg5 : i32
  %2 = vm.mul.i32 %arg1, %c4 : i32
  %3 = vm.mul.i32 %2, %arg2 : i32
  %4 = vm.mul.i32 %2, %arg5 : i32
  %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
  vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
  vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
  vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
^bb2:  // pred: ^bb0
  vm.fail %c2, "device not supported in the compiled configuration"
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func private @_executable_dot_ex_dispatch_0_initializer() -> !vm.ref<!hal.executable> {
  %null = vm.const.ref.zero : !vm.ref<!hal.executable>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
  %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
  %ref_0 = vm.call.variadic @hal.executable.create(%ref, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
  vm.br ^bb3(%ref_0 : !vm.ref<!hal.executable>)
^bb2:  // pred: ^bb0
  vm.br ^bb3(%null : !vm.ref<!hal.executable>)
^bb3(%0: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
  vm.return %0 : !vm.ref<!hal.executable>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
  %c6 = vm.const.i32 6 : i32
  %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.return %ref_0 : !vm.ref<!hal.executable_layout>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c2 = vm.const.i32 2 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.return %ref_0 : !vm.ref<!hal.descriptor_set_layout>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func private @_device_match_id_0_initializer() -> i32 {
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
  %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
  vm.return %0 : i32
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @__init() {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c2 = vm.const.i32 2 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %null = vm.const.ref.zero : !vm.ref<!hal.executable>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
  %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
  vm.global.store.i32 %0, @_device_match_id_0 : i32
  %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
  %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
  %ref_5 = vm.call.variadic @hal.executable.create(%ref_4, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
  vm.br ^bb3(%ref_5 : !vm.ref<!hal.executable>)
^bb2:  // pred: ^bb0
  vm.br ^bb3(%null : !vm.ref<!hal.executable>)
^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
  vm.global.store.ref %1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
  vm.return
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
  %c50331680 = vm.const.i32 50331680 : i32
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
  %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %1 = vm.call @hal.buffer_view.dim(%arg0, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %2 = vm.call @hal.buffer_view.dim(%arg0, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %3 = vm.call @hal.buffer_view.dim(%arg1, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %4 = vm.call @hal.buffer_view.dim(%arg1, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %ref_3:3 = vm.call @dot(%ref_1, %1, %2, %ref_2, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
  %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
  %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %5, ^bb2(%5 : i32), ^bb3
^bb2(%6: i32):  // 2 preds: ^bb0, ^bb1
  vm.fail %6, "semaphore wait failed"
^bb3:  // pred: ^bb1
  vm.return %ref_4 : !vm.ref<!hal.buffer_view>
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
  %c50331680 = vm.const.i32 50331680 : i32
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
  %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
  %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
  vm.return %ref_2 : !vm.ref<!hal.buffer_view>
^bb2(%5: i32):  // pred: ^bb0
  vm.fail %5, "semaphore wait failed"
}

```
{% endraw %}

### IR Dump After Canonicalizer

{% raw %}
```
vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
  %c4 = vm.const.i32 4 : i32
  %c50 = vm.const.i32 50 : i32
  %c14 = vm.const.i32 14 : i32
  %c1 = vm.const.i32 1 : i32
  %c3 = vm.const.i32 3 : i32
  %c20 = vm.const.i32 20 : i32
  %c5 = vm.const.i32 5 : i32
  %zero = vm.const.i32.zero : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %0 = vm.mul.i32 %arg4, %c4 : i32
  %1 = vm.mul.i32 %0, %arg5 : i32
  %2 = vm.mul.i32 %arg1, %c4 : i32
  %3 = vm.mul.i32 %2, %arg2 : i32
  %4 = vm.mul.i32 %2, %arg5 : i32
  %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
  vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
  vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
  vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
  vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
^bb2:  // pred: ^bb0
  vm.fail %c2, "device not supported in the compiled configuration"
}

```
{% endraw %}

### IR Dump After Inliner

{% raw %}
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
    vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
      %c4 = vm.const.i32 4 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.mul.i32 %arg4, %c4 : i32
      %1 = vm.mul.i32 %0, %arg5 : i32
      %2 = vm.mul.i32 %arg1, %c4 : i32
      %3 = vm.mul.i32 %2, %arg2 : i32
      %4 = vm.mul.i32 %2, %arg5 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%5: i32):  // pred: ^bb0
      vm.fail %5, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.ref<!iree.byte_buffer>, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.ref<!iree.byte_buffer>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg0, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %2 = vm.call @hal.buffer_view.dim(%arg0, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg1, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg1, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_3:3 = vm.call @dot(%ref_1, %1, %2, %ref_2, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb3
    ^bb2(%6: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %6, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.func @__init() {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
      %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call.variadic @hal.executable.create(%ref_4, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_5 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.return
    }
    vm.export @__init
  }
}

```
{% endraw %}

### IR Dump After CSE

{% raw %}
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
    vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
      %c4 = vm.const.i32 4 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.mul.i32 %arg4, %c4 : i32
      %1 = vm.mul.i32 %0, %arg5 : i32
      %2 = vm.mul.i32 %arg1, %c4 : i32
      %3 = vm.mul.i32 %2, %arg2 : i32
      %4 = vm.mul.i32 %2, %arg5 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%5: i32):  // pred: ^bb0
      vm.fail %5, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.element_type(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%key : !vm.ref<!iree.byte_buffer>, %operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.query.i32(%device : !vm.ref<!hal.device>, %key : !vm.ref<!iree.byte_buffer>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg0, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %2 = vm.call @hal.buffer_view.dim(%arg0, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg1, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg1, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_3:3 = vm.call @dot(%ref_1, %1, %2, %ref_2, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb3
    ^bb2(%6: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %6, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.func @__init() {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
      %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call.variadic @hal.executable.create(%ref_4, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_5 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.return
    }
    vm.export @__init
  }
}

```
{% endraw %}

### IR Dump After SymbolDCE

{% raw %}
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
    vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
      %c4 = vm.const.i32 4 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.mul.i32 %arg4, %c4 : i32
      %1 = vm.mul.i32 %0, %arg5 : i32
      %2 = vm.mul.i32 %arg1, %c4 : i32
      %3 = vm.mul.i32 %2, %arg2 : i32
      %4 = vm.mul.i32 %2, %arg5 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %4) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %1), (%c1, %arg0, %zero, %3), (%c2, %ref_1, %zero, %4)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%5: i32):  // pred: ^bb0
      vm.fail %5, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg0, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %2 = vm.call @hal.buffer_view.dim(%arg0, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg1, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg1, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_3:3 = vm.call @dot(%ref_1, %1, %2, %ref_2, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb3
    ^bb2(%6: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %6, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.func @__init() {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
      %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call.variadic @hal.executable.create(%ref_4, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_5 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.return
    }
    vm.export @__init
  }
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::VM::SinkDefiningOpsPass

{% raw %}
```
vm.module @module {
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
  vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
  vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c4 = vm.const.i32 4 : i32
    %0 = vm.mul.i32 %arg4, %c4 : i32
    %1 = vm.mul.i32 %arg1, %c4 : i32
    %c50 = vm.const.i32 50 : i32
    %c14 = vm.const.i32 14 : i32
    %2 = vm.mul.i32 %1, %arg5 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %2) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c1 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %zero = vm.const.i32.zero : i32
    vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
    %c2 = vm.const.i32 2 : i32
    %3 = vm.mul.i32 %0, %arg5 : i32
    %4 = vm.mul.i32 %1, %arg2 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %3), (%c1, %arg0, %zero, %4), (%c2, %ref_1, %zero, %2)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
    vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
  ^bb2:  // pred: ^bb0
    vm.fail %c2, "device not supported in the compiled configuration"
  }
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %0, ^bb2(%0 : i32), ^bb1
  ^bb1:  // pred: ^bb0
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %zero = vm.const.i32.zero : i32
    %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %c1 = vm.const.i32 1 : i32
    %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_2 : !vm.ref<!hal.buffer_view>
  ^bb2(%5: i32):  // pred: ^bb0
    vm.fail %5, "semaphore wait failed"
  }
  vm.export @dot$async
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %0, ^bb2(%0 : i32), ^bb1
  ^bb1:  // pred: ^bb0
    %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %1 = vm.call @hal.buffer_view.dim(%arg0, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %c1 = vm.const.i32 1 : i32
    %2 = vm.call @hal.buffer_view.dim(%arg0, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %3 = vm.call @hal.buffer_view.dim(%arg1, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %4 = vm.call @hal.buffer_view.dim(%arg1, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
    %ref_3:3 = vm.call @dot(%ref_1, %1, %2, %ref_2, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
    %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %5, ^bb2(%5 : i32), ^bb3
  ^bb2(%6: i32):  // 2 preds: ^bb0, ^bb1
    vm.fail %6, "semaphore wait failed"
  ^bb3:  // pred: ^bb1
    vm.return %ref_4 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
  vm.func @__init() {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
    %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
    %ref_5 = vm.call.variadic @hal.executable.create(%ref_4, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
    vm.br ^bb3(%ref_5 : !vm.ref<!hal.executable>)
  ^bb2:  // pred: ^bb0
    %null = vm.const.ref.zero : !vm.ref<!hal.executable>
    vm.br ^bb3(%null : !vm.ref<!hal.executable>)
  ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
    vm.global.store.ref %1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    vm.return
  }
  vm.export @__init
}

```
{% endraw %}

### IR Dump After mlir::iree_compiler::IREE::DropCompilerHintsPass

{% raw %}
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_vmla_EC74E8E47AC10E22 dense<[118, 109, 108, 97]> : vector<4xi8>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.rodata @_dot_ex_dispatch_0_vmla_binary_vmla opaque<"_", "0xDEADBEEF"> : vector<1542xi8>
    vm.rodata @_utf8_vmla_BAEA374E0A067A05 dense<[86, 77, 76, 65]> : vector<4xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: i32, %arg2: i32, %arg3: !vm.ref<!hal.buffer>, %arg4: i32, %arg5: i32) -> (!vm.ref<!hal.buffer>, i32, i32) attributes {noinline} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %c4 = vm.const.i32 4 : i32
      %0 = vm.mul.i32 %arg4, %c4 : i32
      %1 = vm.mul.i32 %arg1, %c4 : i32
      %c50 = vm.const.i32 50 : i32
      %c14 = vm.const.i32 14 : i32
      %2 = vm.mul.i32 %1, %arg5 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c14, %2) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %c1 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %zero = vm.const.i32.zero : i32
      vm.call.variadic @hal.command_buffer.push_constants(%ref_2, %_executable_layout_0, %zero, [%arg1, %arg5, %arg4, %arg5, %arg1, %arg2]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ...)
      %c2 = vm.const.i32 2 : i32
      %3 = vm.mul.i32 %0, %arg5 : i32
      %4 = vm.mul.i32 %1, %arg2 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [(%zero, %arg3, %zero, %3), (%c1, %arg0, %zero, %4), (%c2, %ref_1, %zero, %2)]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      vm.call @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, %zero) : (!vm.ref<!hal.command_buffer>, i32, i32, i32) -> ()
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1, %arg1, %arg5 : !vm.ref<!hal.buffer>, i32, i32
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "device not supported in the compiled configuration"
    }
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %zero = vm.const.i32.zero : i32
      %1 = vm.call @hal.buffer_view.dim(%arg2, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %c1 = vm.const.i32 1 : i32
      %2 = vm.call @hal.buffer_view.dim(%arg2, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg3, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg3, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_1:3 = vm.call @dot(%ref, %1, %2, %ref_0, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1#0, %c50331680, [%ref_1#1, %ref_1#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%5: i32):  // pred: ^bb0
      vm.fail %5, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %element_type : i32, %shape : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %flags : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : tuple<i32, !vm.ref<!hal.buffer>, i32, i32> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable.create(%device : !vm.ref<!hal.device>, %executable_format : !vm.ref<!iree.byte_buffer>, %executable_data : !vm.ref<!iree.byte_buffer>, %executable_layouts : !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %push_constants : i32, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I19!B7!d-1d-1B7!d-1d-1R10!B7!d-1d-1", fv = "1"}} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %1 = vm.call @hal.buffer_view.dim(%arg0, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %c1 = vm.const.i32 1 : i32
      %2 = vm.call @hal.buffer_view.dim(%arg0, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %3 = vm.call @hal.buffer_view.dim(%arg1, %zero) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %4 = vm.call @hal.buffer_view.dim(%arg1, %c1) : (!vm.ref<!hal.buffer_view>, i32) -> i32
      %ref_3:3 = vm.call @dot(%ref_1, %1, %2, %ref_2, %3, %4) : (!vm.ref<!hal.buffer>, i32, i32, !vm.ref<!hal.buffer>, i32, i32) -> (!vm.ref<!hal.buffer>, i32, i32)
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3#0, %c50331680, [%ref_3#1, %ref_3#2]) : (!vm.ref<!hal.buffer>, i32, i32 ...) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb3
    ^bb2(%6: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %6, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.func @__init() {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vmla_EC74E8E47AC10E22 = vm.const.ref.rodata @_utf8_vmla_EC74E8E47AC10E22 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vmla_EC74E8E47AC10E22) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, %c6, [%_descriptor_set_layout_0]) : (!vm.ref<!hal.device>, i32, !vm.ref<!hal.descriptor_set_layout> ...) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %_utf8_vmla_BAEA374E0A067A05 = vm.const.ref.rodata @_utf8_vmla_BAEA374E0A067A05 : !vm.ref<!iree.byte_buffer>
      %_dot_ex_dispatch_0_vmla_binary_vmla = vm.const.ref.rodata @_dot_ex_dispatch_0_vmla_binary_vmla : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call.variadic @hal.executable.create(%ref_4, %_utf8_vmla_BAEA374E0A067A05, %_dot_ex_dispatch_0_vmla_binary_vmla, [%_executable_layout_0]) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>, !vm.ref<!iree.byte_buffer>, !vm.ref<!hal.executable_layout> ...) -> !vm.ref<!hal.executable>
      vm.br ^bb3(%ref_5 : !vm.ref<!hal.executable>)
    ^bb2:  // pred: ^bb0
      %null = vm.const.ref.zero : !vm.ref<!hal.executable>
      vm.br ^bb3(%null : !vm.ref<!hal.executable>)
    ^bb3(%1: !vm.ref<!hal.executable>):  // 2 preds: ^bb1, ^bb2
      vm.global.store.ref %1, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.return
    }
    vm.export @__init
  }
}

```
{% endraw %}