---
layout: default
permalink: Dialects/HALDialect
title: "'hal' Dialect"
parent: Dialect Definitions
---

<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'hal' Dialect
{: .no_toc }

A dialect representing operations against the IREE HAL.

This can be thought of as a Vulkan-like model with all of the graphics bits
chopped out.

The type set is limited to those that can be represented in the IREE HAL
design: buffers and views, synchronization primitives like semaphores, and
and command buffers. The intent is that if a device could implement the HAL
interface the sequencer ops could run on that device, such as being able to
run on a GPU via indirect command buffers.

Though this is mostly a 1:1 mapping to the iree::hal API there are some
methods omitted as they are not likely to be needed in IR. It's assumed that
either sequencer interfaces will encapsulate the logic (such as device
resolution) or that certain features are unsafe to expose to user-defined
input.

1. TOC
{:toc}

## Type constraint definition

### allocator
Allocates buffers for a particular device memory space.

### buffer
A memory buffer with a specific memory_type that is used to describe the
capabilities and behavior of the backing memory of the buffer. Buffers may
be any mix of host-accessible, host-coherent, or device-accessible for
various usages. Depending on these memory types the buffers may be mapped
for access on the host as memory though certain restrictions may be imposed.

### buffer_view
A shaped and typed buffer reference. This just wraps an existing hal.buffer
with its associated metadata to make it easier to pass across ABI
boundaries. In most cases buffer views can be elided entirely by the
compiler and they'll only be seen when calling external functions.

### command_buffer
Asynchronous command buffer recording interface. Commands are recorded by
the implementation for later submission to command queues.

### descriptor_set
Descriptor set.

### descriptor_set_layout
Descriptor set layout.

### device
Logical device instance.

### event
Events are used for defining synchronization scopes within CommandBuffers.
An event only exists within a single CommandBuffer and must not be used
across CommandBuffers from the same device or others.

### executable
A prepared and ready-to-dispatch executable.

### executable_layout
An executable layout describing the descriptor sets and push constants used.

### ring_buffer
Ringbuffer used for transient buffer allocation.

### semaphore
Synchronization mechanism for host->device, device->host, host->host,
and device->device notification. Semaphores behave like Vulkan timeline
semaphores (or D3D12 fences) and contain a monotonically increasing
uint64_t payload. They may be waited on any number of times even if they
have already been signaled for a particular value. They may also be waited
on for a particular value prior to the signal for that value.

## Operation definition

### `hal.variable.load.indirect` (::mlir::iree_compiler::IREE::HAL::VariableLoadIndirectOp)

loads a value from a global variable


Syntax:

```
operation ::= `hal.variable.load.indirect` $variable attr-dict `:` type($variable) `->` type($result)
```

Returns a copy of the variable value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`variable` | ptr<index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore>

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore

### `hal.allocator.allocate` (::mlir::iree_compiler::IREE::HAL::AllocatorAllocateOp)

empty buffer allocation operation


Syntax:

```
operation ::= `hal.allocator.allocate` `<` $allocator `:` type($allocator) `>`
              `type` `(` $memory_types `)`
              `usage` `(` $buffer_usage `)`
              `:` custom<SizeAwareType>(type($result), $result_size)
              attr-dict-with-keyword
```

Allocates a buffer of the given size from the allocator.
The size of the buffer returned may be larger than the requested size if the
allocator has specific alignment requirements or minimum allocation sizes.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_types` | mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr | valid MemoryType
`buffer_usage` | mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr | valid BufferUsage

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`result_size` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.allocator.compute_offset` (::mlir::iree_compiler::IREE::HAL::AllocatorComputeOffsetOp)

buffer view indices to byte offset computation operation


Syntax:

```
operation ::= `hal.allocator.compute_offset` `<` $allocator `:` type($allocator) `>`
              `indices` `(` `[` $indices `]` `)`
              `shape` `(` `[` $shape `]` `)`
              `type` `(` $element_type `)`
              `:` type($offset)
              attr-dict-with-keyword
```

Computes an element byte offset within a buffer produced by the allocator.
This returns the same value as `hal.buffer_view.compute_offset`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`shape` | index
`element_type` | 32-bit signless integer
`indices` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index

### `hal.allocator.compute_range` (::mlir::iree_compiler::IREE::HAL::AllocatorComputeRangeOp)

buffer view byte range computation operation


Syntax:

```
operation ::= `hal.allocator.compute_range` `<` $allocator `:` type($allocator) `>`
              `indices` `(` `[` $indices `]` `)`
              `lengths` `(` `[` $lengths `]` `)`
              `shape` `(` `[` $shape `]` `)`
              `type` `(` $element_type `)`
              `:` type($offset) `,` type($length)
              attr-dict-with-keyword
```

Computes a byte range within a buffer for one or more elements.
This returns the same value as `hal.buffer_view.compute_range`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`shape` | index
`element_type` | 32-bit signless integer
`indices` | index
`lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index
`length` | index

### `hal.allocator.compute_size` (::mlir::iree_compiler::IREE::HAL::AllocatorComputeSizeOp)

buffer allocation size computation operation


Syntax:

```
operation ::= `hal.allocator.compute_size` `<` $allocator `:` type($allocator) `>`
              `shape` `(` `[` $shape `]` `)`
              `type` `(` $element_type `)`
              `:` type($result)
              attr-dict-with-keyword
```

Computes the byte size required for a buffer of the given shape and type.
This returns the same value as `hal.buffer_view.byte_length`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`shape` | index
`element_type` | 32-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.allocator.constant` (::mlir::iree_compiler::IREE::HAL::AllocatorConstantOp)

constant buffer allocation operation


Syntax:

```
operation ::= `hal.allocator.constant` `<` $allocator `:` type($allocator) `>`
              `type` `(` $memory_types `)`
              `usage` `(` $buffer_usage `)`
              `:` type($result) `=` $value
              attr-dict-with-keyword
```

Allocates a buffer from the allocator with the given constant contents.
The buffer contents cannot change after the the point of allocation and in
most cases should be cached so that the buffer is not reallocated
repeatedly.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_types` | mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr | valid MemoryType
`buffer_usage` | mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr | valid BufferUsage
`value` | ::mlir::ElementsAttr | constant vector/tensor attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer or buffer_view

### `hal.allocator.map` (::mlir::iree_compiler::IREE::HAL::AllocatorMapOp)

allocator-supported host buffer wrapping operation


Syntax:

```
operation ::= `hal.allocator.map` `<` $allocator `:` type($allocator) `>`
              `source` `(` $source `:` type($source) `)` `` `[` $offset `,` $length `]`
              `type` `(` $memory_types `)`
              `usage` `(` $buffer_usage `)`
              `:` type($result)
              attr-dict-with-keyword
```

Wraps a !hal.buffer around host read-only memory backed by the given byte
buffer. The returned buffer may be host-only and not directly usable on
devices.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_types` | mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr | valid MemoryType
`buffer_usage` | mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr | valid BufferUsage

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`source` | byte_buffer
`offset` | index
`length` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.allocator.pack` (::mlir::iree_compiler::IREE::HAL::AllocatorPackOp)

packs variable-sized slices into a single slab


Syntax:

```
operation ::= `hal.allocator.pack` `<` $allocator `:` type($allocator) `>`
              (`offset` `(` $offset^ `)`)?
              `slices` `(` `{`
              custom<PackSliceRanges>($lifetime_intervals,
              $dynamic_slice_sizes,
              type($packed_offsets))
              `}` `)`
              `:` type($total_length)
              attr-dict-with-keyword
```

Performs a greedy packing of one or more sized slices with specified
lifetimes and returns their relative offsets in an aliased linear space.

Slices are `[start, end] = %slice_byte_size`, where the start and end values
define an inclusive lifetime range and the size is the total number of bytes
required to be live for that range.

```mlir
// Computes thte total length required for the packed values and the offsets
// of the 3 slices requested relative to the base of the packed memory:
%total_length, %offset_0, %offset_1, %offset_2 =
    hal.allocator.pack<%allocator : !hal.allocator>
        // Each slice gets one result offset:
        slices([
          // 3 slices where A and B overlap and will get unique offsets
          // while B and C do not overlap and are allowed to alias.
          [0, 10] = %size_0,  // A => %offset_0
          [3,  8] = %size_1,  // B => %offset_1
          [9, 10] = %size_2,  // C => %offset_2
          ...
        ]) : index
```

The lifetime start and end points (inclusive) are only used for relative
comparisons and may originate with any meaning (op order in block, epoch,
phase of the moon, etc). The packing algorithm uses the intervals to
determine slice liveness and when aliasing is safe.

The size of each slice may either be a constant or runtime-computed dynamic
value. Constant slices can achieve more dense packing than the dynamic
values and CSE/canonicalization should be applied to ensure that as many of
the dynamic values are equivalent if possible.

The total length required to pack all slices is returned and can be used to
acquire storage. The individual slice offsets are 0-based and as such if are
directly used as buffer offsets may need additional offseting. This can
either be applied via the optional `offset` operand or slicing of the
underlying allocation buffer.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`lifetime_intervals` | ::mlir::ArrayAttr | index array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`offset` | index
`dynamic_slice_sizes` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`total_length` | index
`packed_offsets` | index

### `hal.buffer.allocator` (::mlir::iree_compiler::IREE::HAL::BufferAllocatorOp)

buffer allocator accessor operation


Syntax:

```
operation ::= `hal.buffer.allocator` `<` $buffer `:` type($buffer) `>`
              `:` type($result)
              attr-dict-with-keyword
```

Returns the allocator this buffer was allocated from.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer` | buffer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | allocator

### `hal.buffer.length` (::mlir::iree_compiler::IREE::HAL::BufferLengthOp)

buffer byte length accessor


Syntax:

```
operation ::= `hal.buffer.length` `<` $buffer `:` type($buffer) `>`
              `:` type($result)
              attr-dict-with-keyword
```

Returns the allocated size of a buffer in bytes.
May be less than the underlying buffer allocation if this is a subspan or
view into another buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer` | buffer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer.load` (::mlir::iree_compiler::IREE::HAL::BufferLoadOp)

buffer element load operation


Syntax:

```
operation ::= `hal.buffer.load` `<` $source_buffer `:` type($source_buffer) `>`
              `` `[` $source_offset `]`
              `:` type($result)
              attr-dict-with-keyword
```

Loads a value from a buffer by mapping it.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | buffer
`source_offset` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point or vector of any type values

### `hal.buffer.store` (::mlir::iree_compiler::IREE::HAL::BufferStoreOp)

buffer element store operation


Syntax:

```
operation ::= `hal.buffer.store` `<` $target_buffer `:` type($target_buffer) `>`
              `` `[` $target_offset `]`
              `value` `(` $value `:` type($value) `)`
              attr-dict-with-keyword
```

Stores a value into a buffer by mapping it.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | index or signless integer or floating-point or vector of any type values
`target_buffer` | buffer
`target_offset` | index

### `hal.buffer.subspan` (::mlir::iree_compiler::IREE::HAL::BufferSubspanOp)

buffer subspan operation


Syntax:

```
operation ::= `hal.buffer.subspan` `<` $source_buffer `:` type($source_buffer) `>`
              `` `[` $source_offset `,` $length `]`
              `:` type($result)
              attr-dict-with-keyword
```

Returns a reference to a subspan of the buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | buffer
`source_offset` | index
`length` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.buffer_view.buffer` (::mlir::iree_compiler::IREE::HAL::BufferViewBufferOp)

buffer view buffer accessor


Syntax:

```
operation ::= `hal.buffer_view.buffer` $buffer_view attr-dict `:` type($result)
```

Returns the buffer backing this view's contents.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.buffer_view.byte_length` (::mlir::iree_compiler::IREE::HAL::BufferViewByteLengthOp)

buffer view buffer byte length accessor


Syntax:

```
operation ::= `hal.buffer_view.byte_length` $buffer_view attr-dict `:` type($result)
```

Returns the allocated size of a shaped buffer view in bytes.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.compute_offset` (::mlir::iree_compiler::IREE::HAL::BufferViewComputeOffsetOp)

buffer view indices to byte offset computation operation


Syntax:

```
operation ::= `hal.buffer_view.compute_offset` $buffer_view `,`
              `indices` `=` `[` $indices `]`
              attr-dict `:` type($offset)
```

Computes an element byte offset within a buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view
`indices` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index

### `hal.buffer_view.compute_range` (::mlir::iree_compiler::IREE::HAL::BufferViewComputeRangeOp)

buffer view byte range computation operation


Syntax:

```
operation ::= `hal.buffer_view.compute_range` $buffer_view `,`
              `indices` `=` `[` $indices `]` `,`
              `lengths` `=` `[` $lengths `]`
              attr-dict `:` type($offset) `,` type($length)
```

Computes a byte range within a buffer for one or more elements.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view
`indices` | index
`lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index
`length` | index

### `hal.buffer_view.create` (::mlir::iree_compiler::IREE::HAL::BufferViewCreateOp)

buffer view reference initializer


Syntax:

```
operation ::= `hal.buffer_view.create` $buffer `,`
              `element_type` `=` $element_type `,`
              `shape` `=` `[` $shape `]`
              attr-dict `:` type($buffer) `->` type($result)
```

Creates a reference to a buffer with a particular shape and element type.
The buffer is not copied and both the original and view references must be
synchronized. This makes it easier to associate commonly-carried metadata
along with the contents.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer` | buffer
`element_type` | 32-bit signless integer
`shape` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer_view

### `hal.buffer_view.dim` (::mlir::iree_compiler::IREE::HAL::BufferViewDimOp)

buffer view dimension value query


Syntax:

```
operation ::= `hal.buffer_view.dim` $buffer_view `,` $index attr-dict `:` type($result)
```

Returns the value of the given dimension.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`index` | ::mlir::IntegerAttr | index attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.dims` (::mlir::iree_compiler::IREE::HAL::BufferViewDimsOp)

buffer view multi-value dimension query


Syntax:

```
operation ::= `hal.buffer_view.dims` $buffer_view attr-dict `:` type($result)
```

Returns each dimension value of the buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.element_type` (::mlir::iree_compiler::IREE::HAL::BufferViewElementTypeOp)

buffer view element type query


Syntax:

```
operation ::= `hal.buffer_view.element_type` $buffer_view attr-dict `:` type($result)
```

Returns the element type of the buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 32-bit signless integer

### `hal.buffer_view.rank` (::mlir::iree_compiler::IREE::HAL::BufferViewRankOp)

buffer view rank query


Syntax:

```
operation ::= `hal.buffer_view.rank` $buffer_view attr-dict `:` type($result)
```

Returns the rank of the buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.subview` (::mlir::iree_compiler::IREE::HAL::BufferViewSubviewOp)

buffer view subview initializer


Syntax:

```
operation ::= `hal.buffer_view.subview` $buffer_view `,`
              `indices` `=` `[` $indices `]` `,`
              `lengths` `=` `[` $lengths `]`
              attr-dict `:` type($result)
```

Returns a view into a another buffer view. The buffer is not copied and both
the original and sliced references must be synchronized.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view
`indices` | index
`lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer_view

### `hal.buffer_view.trace` (::mlir::iree_compiler::IREE::HAL::BufferViewTraceOp)

trace value(s) operation


Syntax:

```
operation ::= `hal.buffer_view.trace` attr-dict ($operands^ `:` type($operands))?
```

Traces out to a runtime trace sink (console, log file, etc) the given buffer
views and titles them with the given key. The key is informational only and
useful for titling/marking specific sets of buffers for easier searching.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`key` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | buffer_view

### `hal.check_success` (::mlir::iree_compiler::IREE::HAL::CheckSuccessOp)

raises a global failure if a status is not 'ok'


Syntax:

```
operation ::= `hal.check_success` $status (`,` $message^)? attr-dict
```

When the status is not 'ok' this signals a runtime failure that causes the
entire active invocation - and possibly *all* in-flight and pending
invocations - to fail with the given status. The status will be propagated
back via the available runtime error handling mechanisms such as semaphores
or synchronous invocation results.

As the IREE execution model is deeply pipelined it's possible that failures
have a latency between when they are emitted and when the application can
observe the failure. It's also possible that other work that is in-flight
or pending when the failure occurs will complete.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`message` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`status` | 32-bit signless integer

### `hal.command_buffer.begin` (::mlir::iree_compiler::IREE::HAL::CommandBufferBeginOp)

command buffer recording begin operation


Syntax:

```
operation ::= `hal.command_buffer.begin` `<` $command_buffer `:` type($command_buffer) `>`
              attr-dict-with-keyword
```

Resets and begins recording into the command buffer, clearing all previously
recorded contents.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer

### `hal.command_buffer.bind_descriptor_set` (::mlir::iree_compiler::IREE::HAL::CommandBufferBindDescriptorSetOp)

command buffer descriptor set binding operation


Syntax:

```
operation ::= `hal.command_buffer.bind_descriptor_set` `<` $command_buffer `:` type($command_buffer) `>`
              `layout` `(` $executable_layout `:` type($executable_layout) `)`
              `` `[` $set `]`
              `set` `(` $descriptor_set `:` type($descriptor_set) `)`
              (`offsets` `(` `[` $dynamic_offsets^ `]` `)`)?
              attr-dict-with-keyword
```

Binds a descriptor set to the given set number. The provided descriptor set
must not be modified once bound to a command buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable_layout` | executable_layout
`set` | index
`descriptor_set` | descriptor_set
`dynamic_offsets` | index

### `hal.command_buffer.copy_buffer` (::mlir::iree_compiler::IREE::HAL::CommandBufferCopyBufferOp)

command buffer buffer copy recording operation


Syntax:

```
operation ::= `hal.command_buffer.copy_buffer` `<` $command_buffer `:` type($command_buffer) `>`
              `source` `(` $source_buffer `:` type($source_buffer) `)`
              `` `[` $source_offset `]`
              `target` `(` $target_buffer `:` type($target_buffer) `)`
              `` `[` $target_offset `]`
              `length` `(` $length `)`
              attr-dict-with-keyword
```

Copies a range of one buffer to another.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`source_buffer` | buffer
`source_offset` | index
`target_buffer` | buffer
`target_offset` | index
`length` | index

### `hal.command_buffer.create` (::mlir::iree_compiler::IREE::HAL::CommandBufferCreateOp)

command buffer allocation operation


Syntax:

```
operation ::= `hal.command_buffer.create` `device` `(` $device `:` type($device) `)`
              `mode` `(` $modes `)`
              `categories` `(` $command_categories `)`
              `:` type($result)
              attr-dict-with-keyword
```

Returns a command buffer from the device pool ready to begin recording.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`modes` | mlir::iree_compiler::IREE::HAL::CommandBufferModeBitfieldAttr | valid CommandBufferMode
`command_categories` | mlir::iree_compiler::IREE::HAL::CommandCategoryBitfieldAttr | valid CommandCategory

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | command_buffer

### `hal.command_buffer.device` (::mlir::iree_compiler::IREE::HAL::CommandBufferDeviceOp)

command buffer device query operation


Syntax:

```
operation ::= `hal.command_buffer.device` `<` $command_buffer `:` type($command_buffer) `>`
              `:` type($device)
              attr-dict-with-keyword
```

Used during conversion to access the device used to create a command buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer

#### Results:

| Result | Description |
| :----: | ----------- |
`device` | device

### `hal.command_buffer.dispatch.indirect` (::mlir::iree_compiler::IREE::HAL::CommandBufferDispatchIndirectOp)

command buffer indirect dispatch recording operation


Syntax:

```
operation ::= `hal.command_buffer.dispatch.indirect` `<` $command_buffer `:` type($command_buffer) `>`
              `target` `(` $executable `:` type($executable) `)`
              `` `[` $entry_point `]`
              `workgroups` `(` $workgroups_buffer `:` type($workgroups_buffer) `)`
              `` `[` $workgroups_offset `]`
              attr-dict-with-keyword
```

Dispatches an execution request with the dispatch parameters loaded from the
given buffer.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`entry_point` | ::mlir::IntegerAttr | size_t

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable` | executable
`workgroups_buffer` | buffer
`workgroups_offset` | index

### `hal.command_buffer.dispatch.indirect.symbol` (::mlir::iree_compiler::IREE::HAL::CommandBufferDispatchIndirectSymbolOp)

command buffer indirect dispatch recording operation, using symbolref


Syntax:

```
operation ::= `hal.command_buffer.dispatch.indirect.symbol` `<` $command_buffer `:` type($command_buffer) `>`
              `target` `(` $entry_point `)`
              `workgroups` `(` $workgroups_buffer `:` type($workgroups_buffer) `)`
              `` `[` $workgroups_offset `]`
              attr-dict-with-keyword
```

Dispatches an execution request with the dispatch parameters loaded from the
given buffer, using using a nested symbol reference to the entry point.

```mlir
hal.command_buffer.dispatch.indirect.symbol %cmd, @executable::@target::@entry,
                                            workgroups = %buffer[%offset]
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`entry_point` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`workgroups_buffer` | buffer
`workgroups_offset` | index

### `hal.command_buffer.dispatch` (::mlir::iree_compiler::IREE::HAL::CommandBufferDispatchOp)

command buffer dispatch recording operation


Syntax:

```
operation ::= `hal.command_buffer.dispatch` `<` $command_buffer `:` type($command_buffer) `>`
              `target` `(` $executable `:` type($executable) `)`
              `` `[` $entry_point `]`
              `workgroups` `(` `[`
              $workgroup_x `,`
              $workgroup_y `,`
              $workgroup_z
              `]` `)`
              attr-dict-with-keyword
```

Dispatches an execution request.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`entry_point` | ::mlir::IntegerAttr | size_t

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable` | executable
`workgroup_x` | index
`workgroup_y` | index
`workgroup_z` | index

### `hal.command_buffer.dispatch.symbol` (::mlir::iree_compiler::IREE::HAL::CommandBufferDispatchSymbolOp)

command buffer dispatch recording operation, using symbolref


Syntax:

```
operation ::= `hal.command_buffer.dispatch.symbol` `<` $command_buffer `:` type($command_buffer) `>`
              `target` `(` $entry_point `)`
              `workgroups` `(` `[`
              $workgroup_x `,`
              $workgroup_y `,`
              $workgroup_z
              `]` `)`
              attr-dict-with-keyword
```

Dispatches an execution request, using a nested symbol reference to the entry point.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`entry_point` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`workgroup_x` | index
`workgroup_y` | index
`workgroup_z` | index

### `hal.command_buffer.end` (::mlir::iree_compiler::IREE::HAL::CommandBufferEndOp)

command buffer recording end operation


Syntax:

```
operation ::= `hal.command_buffer.end` `<` $command_buffer `:` type($command_buffer) `>`
              attr-dict-with-keyword
```

Ends recording into the command buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer

### `hal.command_buffer.execution_barrier` (::mlir::iree_compiler::IREE::HAL::CommandBufferExecutionBarrierOp)

command buffer execution barrier recording operation


Syntax:

```
operation ::= `hal.command_buffer.execution_barrier` `<` $command_buffer `:` type($command_buffer) `>`
              `source` `(` $source_stage_mask `)`
              `target` `(` $target_stage_mask `)`
              `flags` `(` $flags `)`
              attr-dict-with-keyword
```

Defines an execution dependency between all commands recorded before the
barrier and all commands recorded after the barrier. Only the stages
provided will be affected.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`source_stage_mask` | mlir::iree_compiler::IREE::HAL::ExecutionStageBitfieldAttr | valid ExecutionStage
`target_stage_mask` | mlir::iree_compiler::IREE::HAL::ExecutionStageBitfieldAttr | valid ExecutionStage
`flags` | mlir::iree_compiler::IREE::HAL::ExecutionBarrierFlagBitfieldAttr | valid ExecutionBarrierFlag

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer

### `hal.command_buffer.fill_buffer` (::mlir::iree_compiler::IREE::HAL::CommandBufferFillBufferOp)

command buffer buffer fill recording operation


Syntax:

```
operation ::= `hal.command_buffer.fill_buffer` `<` $command_buffer `:` type($command_buffer) `>`
              `target` `(` $target_buffer `:` type($target_buffer) `)`
              `` `[` $target_offset `,` $length `]`
              `pattern` `(` $pattern `:` type($pattern) `)`
              attr-dict-with-keyword
```

Fills the target buffer with the given repeating value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`target_buffer` | buffer
`target_offset` | index
`length` | index
`pattern` | 32-bit signless integer

### `hal.command_buffer.push_constants` (::mlir::iree_compiler::IREE::HAL::CommandBufferPushConstantsOp)

command buffer push constants operation


Syntax:

```
operation ::= `hal.command_buffer.push_constants` `<` $command_buffer `:` type($command_buffer) `>`
              `layout` `(` $executable_layout `:` type($executable_layout) `)`
              `offset` `(` $offset `)`
              `values` `(` `[` $values `]` `)`
              `:` type($values)
              attr-dict-with-keyword
```

Pushes an inline set of constants that can be accessed by subsequent
dispatches using a compatible executable layout.

Push constants are always 4-byte values and treated as opaque, meaning that
they may be bit-casted floats, bit-packed booleans, etc.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`offset` | ::mlir::IntegerAttr | index attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable_layout` | executable_layout
`values` | 32-bit signless integer

### `hal.command_buffer.push_descriptor_set` (::mlir::iree_compiler::IREE::HAL::CommandBufferPushDescriptorSetOp)

command buffer descriptor set push binding operation


Syntax:

```
operation ::= `hal.command_buffer.push_descriptor_set` `<` $command_buffer `:` type($command_buffer) `>`
              `layout` `(` $executable_layout `:` type($executable_layout) `)`
              `` `[` $set `]`
              `bindings` `(` `[`
              custom<DescriptorSetBindings>($binding_ordinals,
              $binding_buffers,
              type($binding_buffers),
              $binding_offsets,
              $binding_lengths)
              `]` `)`
              attr-dict-with-keyword
```

Pushes an inline-defined descriptor set to the command buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable_layout` | executable_layout
`set` | index
`binding_ordinals` | index
`binding_buffers` | buffer
`binding_offsets` | index
`binding_lengths` | index

### `hal.constant_pool_end` (::mlir::iree_compiler::IREE::HAL::ConstantPoolEndOp)

terminator pseudo-op for the constant pool op


Syntax:

```
operation ::= `hal.constant_pool_end` attr-dict-with-keyword
```


### `hal.constant_pool.load` (::mlir::iree_compiler::IREE::HAL::ConstantPoolLoadOp)

constant pool tensor load pseudo-op


Syntax:

```
operation ::= `hal.constant_pool.load` $constant `:` type($result) attr-dict-with-keyword
```

Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized compile-time constants. Will be replaced with a
direct variable access during transformation.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`constant` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ranked tensor of any type values

### `hal.constant_pool` (::mlir::iree_compiler::IREE::HAL::ConstantPoolOp)

pool of constants with similar lifetimes

A pool of constants that share a similiar lifetime and that should be stored
together both in the source files and at runtime. By logically grouping
constants by their frequency and locality of access we can reduce the number
of bindings required on hal.interface by sourcing constants from the same
buffer. We can also optimize module loading by mapping or DMA transferring
constant data (based on device).

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`buffer_constraints` | BufferConstraintsAttr | structured attribute of BufferConstraintsAttr

### `hal.constant_pool.span` (::mlir::iree_compiler::IREE::HAL::ConstantPoolSpanOp)

constant span within a parent storage block


Syntax:

```
operation ::= `hal.constant_pool.span` $sym_name `:` $tensor_type
              `=` $storage_buffer `[` $storage_range `]`
              (`->` $runtime_buffer^ `[` $runtime_range `]`)?
              attr-dict-with-keyword
```

Represents a constant stored within a hal.constant_pool. Provides a
symbol that can be used to reference the constant data as a stored range
within the module file.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`tensor_type` | ::mlir::TypeAttr | any type attribute
`storage_buffer` | ::mlir::SymbolRefAttr | symbol reference attribute
`storage_range` | ByteRangeAttr | structured attribute of ByteRangeAttr
`runtime_buffer` | ::mlir::SymbolRefAttr | symbol reference attribute
`runtime_range` | ByteRangeAttr | structured attribute of ByteRangeAttr

### `hal.constant_pool.splat` (::mlir::iree_compiler::IREE::HAL::ConstantPoolSplatOp)

constant splat within a parent storage block


Syntax:

```
operation ::= `hal.constant_pool.splat` $sym_name `=` $value
              (`->` $runtime_buffer^ `[` $runtime_range `]`)?
              attr-dict-with-keyword
```

Represents a splatted constant that has no representation in the storage
but must be represented at runtime as splatted 4-byte value.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`value` | ::mlir::ElementsAttr | constant vector/tensor attribute
`runtime_buffer` | ::mlir::SymbolRefAttr | symbol reference attribute
`runtime_range` | ByteRangeAttr | structured attribute of ByteRangeAttr

### `hal.constant_pool.value` (::mlir::iree_compiler::IREE::HAL::ConstantPoolValueOp)

constant value within a parent constant pool


Syntax:

```
operation ::= `hal.constant_pool.value` $sym_name `=` $value attr-dict-with-keyword
```

Represents a constant value as part of a constant pool containing constants
with a similar lifetime.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`value` | ::mlir::ElementsAttr | constant vector/tensor attribute

### `hal.constant_storage.lookup` (::mlir::iree_compiler::IREE::HAL::ConstantStorageLookupOp)

constant storage byte buffer accessor


Syntax:

```
operation ::= `hal.constant_storage.lookup` $constant `:` type($result) attr-dict-with-keyword
```

Returns the read-only host byte buffer storing the constant data.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`constant` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | byte_buffer

### `hal.constant_storage` (::mlir::iree_compiler::IREE::HAL::ConstantStorageOp)

constant data storage block


Syntax:

```
operation ::= `hal.constant_storage` $sym_name `=` $value attr-dict-with-keyword
```

Represents a packed constant storage buffer meeting the buffer constraints
placed on the parent pool. Referenced by other constant pool ops.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`value` | ::mlir::ElementsAttr | constant vector/tensor attribute

### `hal.constant.subspan` (::mlir::iree_compiler::IREE::HAL::ConstantSubspanOp)

runtime constant buffer lookup pseudo-op


Syntax:

```
operation ::= `hal.constant.subspan` $runtime_buffer `[` $runtime_range `]` `:` type($result)
              attr-dict-with-keyword
```

Used during conversion to resolve a runtime representation of a constant as
a tensor backed by a buffer range.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`runtime_buffer` | ::mlir::SymbolRefAttr | symbol reference attribute
`runtime_range` | ByteRangeAttr | structured attribute of ByteRangeAttr

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ranked tensor of any type values

### `hal.descriptor_set.create` (::mlir::iree_compiler::IREE::HAL::DescriptorSetCreateOp)

allocates a descriptor set from the device pool


Syntax:

```
operation ::= `hal.descriptor_set.create` `device` `(` $device `:` type($device) `)`
              `layout` `(` $set_layout `:` type($set_layout) `)`
              `bindings` `(` `[`
              custom<DescriptorSetBindings>($binding_ordinals,
              $binding_buffers,
              type($binding_buffers),
              $binding_offsets,
              $binding_lengths)
              `]` `)`
              attr-dict-with-keyword
```

Creates a DescriptorSet from the device pool.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`set_layout` | descriptor_set_layout
`binding_ordinals` | index
`binding_buffers` | buffer
`binding_offsets` | index
`binding_lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | descriptor_set

### `hal.descriptor_set_layout.create` (::mlir::iree_compiler::IREE::HAL::DescriptorSetLayoutCreateOp)

creates a descriptor set layout


Syntax:

```
operation ::= `hal.descriptor_set_layout.create` `device` `(` $device `:` type($device) `)`
              `usage` `(` $usage_type `)`
              `bindings` `(` $bindings `)`
              `:` type($result)
              attr-dict-with-keyword
```

Creates a descriptor set layout that defines the bindings used within a set.
The same descriptor set layout may be shared with many different executable
layouts and by doing so some runtime binding overhead when switching between
executables that use the same set layouts can be reduced.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`usage_type` | ::mlir::iree_compiler::IREE::HAL::DescriptorSetLayoutUsageTypeAttr | IREE HAL DescriptorSetLayoutType
`bindings` | ::mlir::ArrayAttr | HAL descriptor set layout binding array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | descriptor_set_layout

### `hal.descriptor_set_layout.lookup` (::mlir::iree_compiler::IREE::HAL::DescriptorSetLayoutLookupOp)

descriptor set layout cache lookup pseudo-op


Syntax:

```
operation ::= `hal.descriptor_set_layout.lookup` `device` `(` $device `:` type($device) `)`
              `usage` `(` $usage_type `)`
              `bindings` `(` $bindings `)`
              `:` type($result)
              attr-dict-with-keyword
```

Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized descriptor set layout.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`usage_type` | ::mlir::iree_compiler::IREE::HAL::DescriptorSetLayoutUsageTypeAttr | IREE HAL DescriptorSetLayoutType
`bindings` | ::mlir::ArrayAttr | HAL descriptor set layout binding array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | descriptor_set_layout

### `hal.device.allocator` (::mlir::iree_compiler::IREE::HAL::DeviceAllocatorOp)

device allocator accessor operation


Syntax:

```
operation ::= `hal.device.allocator` `<` $device `:` type($device) `>` `:` type($result) attr-dict-with-keyword
```

Returns the allocator that can be used to allocate buffers compatible with
the device.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | allocator

### `hal.device.match.id` (::mlir::iree_compiler::IREE::HAL::DeviceMatchIDOp)

returns true if the device ID matches the pattern


Syntax:

```
operation ::= `hal.device.match.id` `<` $device `:` type($device) `>`
              `pattern` `(` $pattern `)`
              `:` type($result)
              attr-dict-with-keyword
```

Pattern matches the device ID with the given wildcard pattern.
This can be used to conditionally evaluate device-specific code when the
device is not known at compile-time.

```mlir
%is_match = hal.device.match.id<%device : !hal.device>
                        pattern("vulkan-*") : i1
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`pattern` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 1-bit signless integer

### `hal.device.match.memory_model` (::mlir::iree_compiler::IREE::HAL::DeviceMatchMemoryModelOp)

returns true if the device memory model matches the value


Syntax:

```
operation ::= `hal.device.match.memory_model` `<` $device `:` type($device) `>`
              `value` `(` $model `)`
              `:` type($result)
              attr-dict-with-keyword
```

Compares the device's memory model against the specified model.
This can be used to conditionally evaluate device-specific code when the
device is not known at compile-time.

```mlir
%is_match = hal.device.match.memory_model<%device : !hal.device>
                                    value("Unified") : i1
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`model` | ::mlir::iree_compiler::IREE::HAL::MemoryModelAttr | IREE HAL MemoryModel

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 1-bit signless integer

### `hal.device.query` (::mlir::iree_compiler::IREE::HAL::DeviceQueryOp)

returns a runtime configuration parameter from the device


Syntax:

```
operation ::= `hal.device.query` `<` $device `:` type($device) `>`
              `key` `(` $key `)`
              `:` type($ok) `,` type($value)
              attr-dict-with-keyword
```

Queries a device configuration parameter with the given key.
Returns a status indicating whether the key was recognized/available and if
it was the value converted to the specified type. Queries must return the
same value for the lifetime of the module though may vary from run to run.

This is roughly equivalent to the `sysconf` linux syscall
(https://man7.org/linux/man-pages/man3/sysconf.3.html) in that the exact
set of keys available and their interpretation is target-dependent. If there
is a HAL match attribute (`#hal.device.match.*`) or op
(`hal.device.match.*`) prefer to use that in order to get compile-time
propagation when the target is specified and elide the runtime query and
get compile-time verification when a runtime query is required.

Users of the op must check the `ok` result before using the value as what
set of keys is available may change over time. If in doubt: don't use this.
Each key used adds additional versioning and testing complexity as runtime
code path changes will explode combinatorially and should be treated with as
much care as a binary file format change. Keys should be prefixed with `ex.`
when experimental indicating that they are not expected to be present
forever; all non-experimental keys should be vetted.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`key` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`ok` | 1-bit signless integer
`value` | any type

### `hal.device.switch` (::mlir::iree_compiler::IREE::HAL::DeviceSwitchOp)

runtime device switch pseudo op

Switches between multiple regions based on the runtime device type.
The provided regions are matched against the runtime backend of the given
device and executed only when the device matches the conditions.

Conditions can match on wildcards and be folded to enable conditions that
have similar bodies to be folded. The patterns themselves are only matched
once at startup and then the results are cached; the runtime overhead is
equivalent to a normal switch statement. In cases where the compiler can
statically identify the device type entire cases can be folded away.

Supported conditions:
* `#hal.match...`: execute the region if the expression matches.

Supported match expressions:
* `#hal.match.always`: always matches; useful for defaults.
* `#hal.match.any<[...]>`: matches if any of the nested expressions match.
* `#hal.match.all<[...]>`: matches only if all of the nested expressions
  match.
* `#hal.device.match.id<"pattern*-?-*">`: matches against the device
  identifier. The pattern is evaluated with standard file path wildcards
  (`*` for zero or more characters and `?` for one character).

If more than one condition is satisfied the first listed will be chosen.
More specific conditions should be earlier in the set. If no condition is
matched but there are return values the switch will abort at runtime. It's
strongly recommend that all switches that return values end with a trailing
`#hal.match.always` condition to handle the fallthrough case.

Upon creation each condition region will have an empty entry block with the
specified operands available as arguments. Each region must be setup to
return the same types.

```mlir
%c0 = constant 0 : i32
%c1 = constant 1 : i32
%c2 = constant 2 : i32
%device = ... : !hal.device
%0 = hal.device.switch<%device : !hal.device> -> i32
  #hal.device.match.id<"vulkan-v1.?-*">(%c1a = %c1 : i32) {
    hal.return %c1a : i32
  },
  #hal.match.any<[#hal.device.match.id<"vmla">, #hal.device.match.id<"vulkan-*">]>(%c2a = %c2 : i32) {
    hal.return %c2a : i32
  },
  #hal.match.always(%c0a = %c0 : i32) {
    hal.return %c0a : i32
  }
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`conditions` | ::mlir::ArrayAttr | array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`args` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `hal.ex.shared_device` (::mlir::iree_compiler::IREE::HAL::ExSharedDeviceOp)




Syntax:

```
operation ::= `hal.ex.shared_device` attr-dict `:` type($result)
```


#### Results:

| Result | Description |
| :----: | ----------- |
`result` | device

### `hal.ex.submit_and_wait` (::mlir::iree_compiler::IREE::HAL::ExSubmitAndWaitOp)




Syntax:

```
operation ::= `hal.ex.submit_and_wait` $device `,` $command_buffer attr-dict
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`command_buffer` | command_buffer

### `hal.executable.binary_end` (::mlir::iree_compiler::IREE::HAL::ExecutableBinaryEndOp)

terminator pseudo-op for the executable binary op


Syntax:

```
operation ::= `hal.executable.binary_end` attr-dict
```


### `hal.executable.binary` (::mlir::iree_compiler::IREE::HAL::ExecutableBinaryOp)

compiled executable binary data

A compiled executable binary with an optional nested module containing the
IR prior to serialization (for debugging).

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`format` | ::mlir::StringAttr | string attribute
`data` | ::mlir::DenseIntElementsAttr | 8-bit signless integer elements attribute

### `hal.executable.create` (::mlir::iree_compiler::IREE::HAL::ExecutableCreateOp)

creates an executable


Syntax:

```
operation ::= `hal.executable.create` `device` `(` $device `:` type($device) `)`
              `target` `(` $executable_target `)`
              `layouts` `(` `[` $layouts `]` `)`
              `:` type($result)
              attr-dict-with-keyword
```

Creates a target-dependent executable cached on the provided device. Entry
points contained within the executable can be dispatched using the resulting
executable handle.

Depending on the driver creation may take a non-trivial amount of time
(such as when JITing/etc). As the cache is internally synchronized callers
can issue preparation requests from multiple threads - even for the same
executables - and calls will block until preparation completes.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`executable_target` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`layouts` | executable_layout

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable

### `hal.executable_end` (::mlir::iree_compiler::IREE::HAL::ExecutableEndOp)

terminator pseudo-op for the executable op


Syntax:

```
operation ::= `hal.executable_end` attr-dict
```


### `hal.executable.entry_point` (::mlir::iree_compiler::IREE::HAL::ExecutableEntryPointOp)

executable entry point declaration

An entry point exported by the executable with statically-available
information describing the IO interface it uses and other dispatch metadata.

The optional `workgroup_count_region` region represents the
computation that returns the number of workgroups to use. The
arguments to the region represents the workload along x, y and
z. It returns the number of workgroups along x, y, and z.

TODO(ravishankarm): In reality there is no need to define what the
arguments represent. They could be any values that are needed to
compute the number of workgroups. Its unclear what these are in
general and how to plumb them through. So for now just accepting
the workload along x, y, and z.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`ordinal` | ::mlir::IntegerAttr | size_t
`interface` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
`signature` | ::mlir::TypeAttr | any type attribute
`workgroup_size` | ::mlir::ArrayAttr | index array attribute

### `hal.executable_layout.create` (::mlir::iree_compiler::IREE::HAL::ExecutableLayoutCreateOp)

creates an executable layout


Syntax:

```
operation ::= `hal.executable_layout.create` `device` `(` $device `:` type($device) `)`
              `push_constants` `(` $push_constants `)`
              `layouts` `(` `[` $set_layouts `]` `)`
              `:` type($result)
              attr-dict-with-keyword
```

Creates an executable layout from the given descriptor sets and push
constant required size. Executable layouts can be shared across any
executable that uses the same layout and push constant information. Sharing
the layout between executables will reduce runtime binding overhead and it
is often worth the cost to allow a small number of unused bindings in one
executable such that it can share layouts with others that will be scheduled
adjacent to it.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`push_constants` | ::mlir::IntegerAttr | index attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`set_layouts` | descriptor_set_layout

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable_layout

### `hal.executable_layout.lookup` (::mlir::iree_compiler::IREE::HAL::ExecutableLayoutLookupOp)

executable layout cache lookup pseudo-op


Syntax:

```
operation ::= `hal.executable_layout.lookup` `device` `(` $device `:` type($device) `)`
              (`push_constants` `(` $push_constants^ `)`)?
              `layouts` `(` $set_layouts `)`
              `:` type($result)
              attr-dict-with-keyword
```

Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized executable layout.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`push_constants` | ::mlir::IntegerAttr | index attribute
`set_layouts` | ::mlir::ArrayAttr | array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable_layout

### `hal.executable.lookup` (::mlir::iree_compiler::IREE::HAL::ExecutableLookupOp)

executable cache lookup pseudo-op


Syntax:

```
operation ::= `hal.executable.lookup` `device` `(` $device `:` type($device) `)`
              `executable` `(` $executable `)`
              `:` type($result)
              attr-dict-with-keyword
```

Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized executable.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`executable` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable

### `hal.executable` (::mlir::iree_compiler::IREE::HAL::ExecutableOp)

target-specific executable module

An executable module representing a target-specific compiled
kernel/shader/etc.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute

### `hal.executable.target_end` (::mlir::iree_compiler::IREE::HAL::ExecutableTargetEndOp)

terminator pseudo-op for the executable target op


Syntax:

```
operation ::= `hal.executable.target_end` attr-dict
```


### `hal.executable.target` (::mlir::iree_compiler::IREE::HAL::ExecutableTargetOp)

target executable IR

The target IR for the executable. This can be preserved for debugging but
is usually removed during transformation.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`target_backend_filter` | ::mlir::StringAttr | string attribute

### `hal.interface.binding` (::mlir::iree_compiler::IREE::HAL::InterfaceBindingOp)

executable IO binding description

Defines an IO binding used to pass buffers into the executable for loads and
stores. These bindings will be mapped into descriptor sets by the scheduler
based on device support and usage within the command buffer.

Bindings are typeless and only indicate a resource that is made available to
executables. The types that can be loaded-from and stored-into the binding
buffers are provided to backends by way of the `hal.interface.load.*` and
`hal.interface.store.*` ops.

Bindings do not need to correlate 1:1 with entry point arguments/results and
in many cases will not. For example, the same binding may be used with
different offsets if the arguments were packed into a ringbuffer/arena by
the scheduler.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`set` | ::mlir::IntegerAttr | index attribute
`binding` | ::mlir::IntegerAttr | index attribute
`type` | ::mlir::iree_compiler::IREE::HAL::DescriptorTypeAttr | IREE HAL DescriptorType
`access` | mlir::iree_compiler::IREE::HAL::MemoryAccessBitfieldAttr | valid MemoryAccess

### `hal.interface.binding.subspan` (::mlir::iree_compiler::IREE::HAL::InterfaceBindingSubspanOp)

returns an alias to a subspan of interface binding data


Syntax:

```
operation ::= `hal.interface.binding.subspan` $binding `[` $byte_offset ( `,` $byte_length^ )? `]`
              attr-dict `:` type($result)
```

// TODO(benvanik): add description

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`byte_offset` | index
`byte_length` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | any type

### `hal.interface_end` (::mlir::iree_compiler::IREE::HAL::InterfaceEndOp)

terminator pseudo-op for the executable interface op


Syntax:

```
operation ::= `hal.interface_end` attr-dict
```


### `hal.interface.load.constant` (::mlir::iree_compiler::IREE::HAL::InterfaceLoadConstantOp)

loads a constant value from the interface constant block


Syntax:

```
operation ::= `hal.interface.load.constant` `offset` `=` $offset attr-dict `:` type($result)
```

Loads a scalar constant value from an executable IO push constant block.
The value will be loaded from the given constant offset and will be
bitcast (possibly with truncation or zero-extension) to the result type.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`offset` | ::mlir::IntegerAttr | size_t

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point

### `hal.interface.load.tensor` (::mlir::iree_compiler::IREE::HAL::InterfaceLoadTensorOp)

loads a tensor from an executable IO binding


Syntax:

```
operation ::= `hal.interface.load.tensor` $binding `,` `offset` `=` $offset attr-dict `:` type($result)
```

Loads a tensor value from an executable IO binding. This is a pseudo op
that can be used to tie SSA tensor values in the IR to the bindings that
contain those tensors.

Note that because there may not be a 1:1 mapping between original tensor
arguments to the entry point function and the bindings in the interface the
backend must use the offset provided on this op to properly compute the base
address of the tensor data. The offset is in bytes relative to the base
binding address, irrespective of the type of the tensor loaded by this
operation.

The offset provided, if non-zero, will have an alignment compatible with the
tensor type represented. For example, a `tensor<16xf32>` will be aligned on
at least a 4 byte boundary.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`offset` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ranked tensor of any type values

### `hal.interface.load.tensor.tile` (::mlir::iree_compiler::IREE::HAL::InterfaceLoadTensorTileOp)

loads a tensor tile from an executable IO binding


Syntax:

```
operation ::= `hal.interface.load.tensor.tile` $binding `,`
              `base_offset` `=` $base_offset `,`
              `offsets` `=`
              custom<OperandsOrIntegersOffsetsOrStridesList>($offsets, $static_offsets) `,`
              `sizes` `=`
              custom<OperandsOrIntegersSizesList>($sizes, $static_sizes) `,`
              `strides` `=`
              custom<OperandsOrIntegersOffsetsOrStridesList>($strides, $static_strides)
              attr-dict `:` type($result)
```

Loads a tensor tile value from an executable IO binding at the given
offset/size/stride. This is a pseudo op that can be used to tie SSA tensor
values in the IR to the bindings that contain those tensors.

Note that because there may not be a 1:1 mapping between original tensor
arguments to the entry point function and the bindings in the interface the
backend must use the offset provided on this op to properly compute the base
address of the tensor data. The offset is in bytes relative to the base
binding address, irrespective of the type of the tensor loaded by this
operation.

The base_offset provided, if non-zero, will have an alignment compatible
with the tensor type represented. For example, a `tensor<16xf32>` will be
aligned on at least a 4 byte boundary.

The op follows the semantic of similar core MLIR strided subview / subtensor
ops where offset-list, size-list and stride-list are SSA value or constants
of type index.

Example:
```
  `hal.interface.load.tensor.tile` $binding `,`
    `base_offset` `=` base_offset `,`
    `offsets` `=` `[` offset-list `]` `,`
    `sizes` `=` `[` size-list `]` `,`
    `strides` `=` `[` stride-list `]` attr-dict `:` type($result)
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute
`static_offsets` | ::mlir::ArrayAttr | 64-bit integer array attribute
`static_sizes` | ::mlir::ArrayAttr | 64-bit integer array attribute
`static_strides` | ::mlir::ArrayAttr | 64-bit integer array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`base_offset` | index
`offsets` | index
`sizes` | index
`strides` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ranked tensor of any type values

### `hal.interface` (::mlir::iree_compiler::IREE::HAL::InterfaceOp)

executable IO interface description

Defines a set of IO bindings and associated information required for the
scheduler to correctly dispatch the executable. Multiple executable binaries
can share the same interface to reduce the amount of scheduling code
generated, or a single executable binary can expose entry points with
multiple different interfaces to allow for runtime selection based on
supported device capabilities.

The design is modeled on the Vulkan binding model, which uses one or more
descriptor sets containing one or more bindings as part of its API. By using
the same representation here we can get toll-free lowering on the Vulkan and
SPIR-V side, and for other backends that may have simpler models the cost is
negligable (just an extra indirection during dispatch). For more information
on the Vulkan binding model see the documentation (which contains GLSL,
SPIR-V, and Vulkan API examples that directly map to our use here):
https://vulkan.lunarg.com/doc/view/1.0.33.0/linux/vkspec.chunked/ch13s02.html

For background as to how multiple descriptor sets are used by the scheduler
see: https://developer.nvidia.com/vulkan-shader-resource-binding

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`push_constants` | ::mlir::IntegerAttr | index attribute

### `hal.interface.store.tensor` (::mlir::iree_compiler::IREE::HAL::InterfaceStoreTensorOp)

stores a tensor in an executable IO binding


Syntax:

```
operation ::= `hal.interface.store.tensor` $operand `,` $binding `,` `offset` `=` $offset
              attr-dict `:` type($operand)
```

Stores a tensor value into an executable IO binding. This is a pseudo op
indicating that the value of the operand tensor should be stored into the
specified binding.

Note that because there may not be a 1:1 mapping between original tensor
arguments to the entry point function and the bindings in the interface the
backend must use the offset provided on this op to properly compute the base
address of the tensor data. The offset is in bytes relative to the base
binding address, irrespective of the type of the tensor loaded by this
operation.

The offset provided, if non-zero, will have an alignment compatible with the
tensor type represented. For example, a `tensor<16xf32>` will be aligned on
at least a 4 byte boundary.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | ranked tensor of any type values
`offset` | index

### `hal.interface.store.tensor.tile` (::mlir::iree_compiler::IREE::HAL::InterfaceStoreTensorTileOp)

stores a tensor tile in an executable IO binding


Syntax:

```
operation ::= `hal.interface.store.tensor.tile` $operand `,` $binding `,`
              `base_offset` `=` $base_offset `,`
              `offsets` `=`
              custom<OperandsOrIntegersOffsetsOrStridesList>($offsets, $static_offsets) `,`
              `sizes` `=`
              custom<OperandsOrIntegersSizesList>($sizes, $static_sizes) `,`
              `strides` `=`
              custom<OperandsOrIntegersOffsetsOrStridesList>($strides, $static_strides)
              attr-dict `:` type($operand)
```

Stores a tensor value into an executable IO binding. This is a pseudo op
indicating that the value of the operand tensor should be stored into the
specified binding at the given offset/size/stride.

Note that because there may not be a 1:1 mapping between original tensor
arguments to the entry point function and the bindings in the interface the
backend must use the offset provided on this op to properly compute the base
address of the tensor data. The offset is in bytes relative to the base
binding address, irrespective of the type of the tensor loaded by this
operation.

The base_offset provided, if non-zero, will have an alignment compatible
with the tensor type represented. For example, a `tensor<16xf32>` will be
aligned on at least a 4 byte boundary.

The op follows the semantic of similar core MLIR strided subview / subtensor
ops where offset-list, size-list and stride-list are SSA value or constants
of type index.

Grammar:
```
  `hal.interface.store.tensor.tile` $operand `,` $binding `,`
    `base_offset` `=` base_offset `,`
    `offsets` `=` `[` offset-list `]` `,`
    `sizes` `=` `[` size-list `]` `,`
    `strides` `=` `[` stride-list `]` attr-dict `:` type($operand)
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute
`static_offsets` | ::mlir::ArrayAttr | 64-bit integer array attribute
`static_sizes` | ::mlir::ArrayAttr | 64-bit integer array attribute
`static_strides` | ::mlir::ArrayAttr | 64-bit integer array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | ranked tensor of any type values
`base_offset` | index
`offsets` | index
`sizes` | index
`strides` | index

### `hal.interface.workgroup.count` (::mlir::iree_compiler::IREE::HAL::InterfaceWorkgroupCountOp)

returns the total workgroup count of the grid


Syntax:

```
operation ::= `hal.interface.workgroup.count` `[` $dimension `]` attr-dict `:` type($result)
```

The total number of workgroups along each dimension in the dispatch grid.
Matches what was passed to the `hal.command_buffer.dispatch` command (or
what was indirectly specified).

Corresponds to the `NumWorkgroups` SPIR-V built-in and the `gridDim` CUDA
built-in variable.

```mlir
%x = hal.interface.workgroup.count[0] : index
%y = hal.interface.workgroup.count[1] : index
%z = hal.interface.workgroup.count[2] : index
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`dimension` | ::mlir::IntegerAttr | index attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.interface.workgroup.id` (::mlir::iree_compiler::IREE::HAL::InterfaceWorkgroupIDOp)

returns the index of the current workgroup in the grid


Syntax:

```
operation ::= `hal.interface.workgroup.id` `[` $dimension `]` attr-dict `:` type($result)
```

The global workgroup ID of the current tile in the range of
`[0, hal.interface.workgroup.count)` along each XYZ dimension.

Corresponds to the `WorkgroupId` SPIR-V built-in and the `blockIdx` CUDA
built-in variable.

```mlir
%x = hal.interface.workgroup.id[0] : index
%y = hal.interface.workgroup.id[1] : index
%z = hal.interface.workgroup.id[2] : index
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`dimension` | ::mlir::IntegerAttr | index attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.interface.workgroup.size` (::mlir::iree_compiler::IREE::HAL::InterfaceWorkgroupSizeOp)

returns the size of each workgroup in invocations


Syntax:

```
operation ::= `hal.interface.workgroup.size` `[` $dimension `]` attr-dict `:` type($result)
```

The number of local invocations within the current workgroup along each
dimension. Depending on backend this may map to the SIMT thread count or
inner loop nest parameters.

Corresponds to the `WorkgroupSize` SPIR-V built-in and the `blockDim` CUDA
built-in variable.

```mlir
%x = hal.interface.workgroup.size[0] : index
%y = hal.interface.workgroup.size[1] : index
%z = hal.interface.workgroup.size[2] : index
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`dimension` | ::mlir::IntegerAttr | index attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.return` (::mlir::iree_compiler::IREE::HAL::ReturnOp)

return from a hal.device.switch region


Syntax:

```
operation ::= `hal.return` ($operands^ `:` type($operands))? attr-dict
```

Returns the given values from the region and back to the host code.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | any type

### `hal.semaphore.await` (::mlir::iree_compiler::IREE::HAL::SemaphoreAwaitOp)

asynchronous semaphore wait operation


Syntax:

```
operation ::= `hal.semaphore.await` `<` $semaphore `:` type($semaphore) `>`
              `until` `(` $min_value `)`
              `:` type($status)
              attr-dict-with-keyword
```

Yields the caller until the semaphore reaches or exceeds the specified
payload `min_value`. Returns the `status` of the semaphore after the wait,
with a non-zero value indicating failure.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore
`min_value` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`status` | 32-bit signless integer

### `hal.semaphore.create` (::mlir::iree_compiler::IREE::HAL::SemaphoreCreateOp)

semaphore allocation operation


Syntax:

```
operation ::= `hal.semaphore.create` `device` `(` $device `:` type($device) `)`
              `initial` `(` $initial_value `)`
              `:` type($result)
              attr-dict-with-keyword
```

Returns a semaphore from the device pool with the given initial value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`initial_value` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | semaphore

### `hal.semaphore.fail` (::mlir::iree_compiler::IREE::HAL::SemaphoreFailOp)

semaphore asynchronous failure operation


Syntax:

```
operation ::= `hal.semaphore.fail` `<` $semaphore `:` type($semaphore) `>`
              `status` `(` $status `)`
              attr-dict-with-keyword
```

Signals the semaphore with a failure. The `status` will be returned from
`hal.semaphore.query` and `hal.semaphore.signal` for the lifetime
of the semaphore.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore
`status` | 32-bit signless integer

### `hal.semaphore.query` (::mlir::iree_compiler::IREE::HAL::SemaphoreQueryOp)

semaphore payload value query


Syntax:

```
operation ::= `hal.semaphore.query` `<` $semaphore `:` type($semaphore) `>`
              `:` type($status) `,` type($value)
              attr-dict-with-keyword
```

Queries the current payload and returns a tuple of `(status, value)`.
As the payload is monotonically increasing it is guaranteed that
the value is at least equal to the previous result of a
`hal.semaphore.signal` call and coherent with any waits for a
specified value via `hal.semaphore.await`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore

#### Results:

| Result | Description |
| :----: | ----------- |
`status` | 32-bit signless integer
`value` | index

### `hal.semaphore.signal` (::mlir::iree_compiler::IREE::HAL::SemaphoreSignalOp)

semaphore payload value signal operation


Syntax:

```
operation ::= `hal.semaphore.signal` `<` $semaphore `:` type($semaphore) `>`
              `value` `(` $new_value `)`
              attr-dict-with-keyword
```

Signals the semaphore to the given payload value.
The call is ignored if the current payload value exceeds `new_value`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore
`new_value` | index

### `hal.variable.address` (::mlir::iree_compiler::IREE::HAL::VariableAddressOp)

returns an address reference to a variable


Syntax:

```
operation ::= `hal.variable.address` $variable attr-dict `:` type($result)
```

Returns the address of a variable as a typed reference. Can be used with the
variable load and store indirect ops.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`variable` | FlatSymbolRefAttr | symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ptr<index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore>

### `hal.variable.load` (::mlir::iree_compiler::IREE::HAL::VariableLoadOp)

loads a value from a global variable


Syntax:

```
operation ::= `hal.variable.load` $variable attr-dict `:` type($result)
```

Returns a copy of the variable value.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`variable` | FlatSymbolRefAttr | symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore

### `hal.variable` (::mlir::iree_compiler::IREE::HAL::VariableOp)

stateful variable declaration

Declares a global variable that maintains its value across invocations.
The value is tied to the execution context of the module and different
contexts will have different variable storage.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`type` | ::mlir::TypeAttr | any type attribute
`is_mutable` | ::mlir::UnitAttr | unit attribute
`initializer` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
`initial_value` | ::mlir::Attribute | any attribute

### `hal.variable.store.indirect` (::mlir::iree_compiler::IREE::HAL::VariableStoreIndirectOp)

stores a value into a global variable


Syntax:

```
operation ::= `hal.variable.store.indirect` $value `,` $variable attr-dict `:` type($value) `->` type($variable)
```

Stores a copy of the value into a variable.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore
`variable` | ptr<index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore>

### `hal.variable.store` (::mlir::iree_compiler::IREE::HAL::VariableStoreOp)

stores a value into a global variable


Syntax:

```
operation ::= `hal.variable.store` $value `,` $variable attr-dict `:` type($value)
```

Stores a copy of the value into a variable.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`variable` | FlatSymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_layout or ring_buffer or semaphore
