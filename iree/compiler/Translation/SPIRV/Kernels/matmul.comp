// Simple tiled GEMM.
// The compiler emits this handwritten kernel for GEMM operations. Right now
// this prevents fusion with the GEMM dispatch, however in the future we can
// do some SPIR-V module merging tricks to make fusing possible.
//
// Since this is a special well-known kernel we can use specialization constants
// if we want to create variants for GEMV. Alternative vendor-specific
// implementations (such as one using VK_NV_cooperative_matrix) will need to be
// in separate files as we need some special handing for required extensions.

#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, binding = 0) buffer readonly arg0_binding {
   float arg0[];
};
layout(std430, binding = 1) buffer readonly arg1_binding {
   float arg1[];
};
layout(std430, binding = 2) buffer writeonly ret0_binding {
   float ret0[];
};

// Derived from the shapes of [arg0, arg1, ret0] and passed as specialization
// constants to the particular executable instance.
// Note that when we can generate this (or fully round-trip it) in the MLIR
// SPIR-V dialect we won't need to do this but can instead substitute at compile
// time. I can't wait :)
//   arg0 = [b0, m, k]
//   arg1 = [b0, k, n]
//   ret0 = [b0, m, n]
layout(constant_id = 100) const uint kMatrixM = 0;
layout(constant_id = 101) const uint kMatrixK = 0;
layout(constant_id = 102) const uint kMatrixN = 0;

const uint kTileSize = gl_WorkGroupSize.x;  // .x == .y
uint kTileCount = (kMatrixK - 1) / kTileSize + 1;

shared float tile_lhs[kTileSize][kTileSize];
shared float tile_rhs[kTileSize][kTileSize];

// TODO(benvanik): spec constants to remove the bounds checking.
// TODO(benvanik): rely on robustness to do the check for us.
// TODO(benvanik): treat as externs so the SPIR-V generator can plug in.
float ReadLHS(uint row, uint col) {
  if (row < kMatrixM && col < kMatrixK) {
    return arg0[row * kMatrixK + col];
  } else {
    return 0.0;
  }
}

float ReadRHS(uint row, uint col) {
  if (row < kMatrixK && col < kMatrixN) {
    return arg1[row * kMatrixN + col];
  } else {
    return 0.0;
  }
}

void WriteOut(uint row, uint col, float value) {
  if (col < kMatrixN && row < kMatrixM) {
    ret0[row * kMatrixN + col] = value;
  }
}

void main() {
  uint matrix_row = gl_GlobalInvocationID.y;  // 0..kMatrixM
  uint matrix_col = gl_GlobalInvocationID.x;  // 0..kMatrixK
  uint tile_row = gl_LocalInvocationID.y;  // 0..kTileSize
  uint tile_col = gl_LocalInvocationID.x;  // 0..kTileSize
  float acc = 0.0;
  for (uint t = 0; t < kTileCount; ++t) {
    // Load one tile of the LHS and the RHS into local memory.
    uint tiled_lhs_col = kTileSize * t + tile_col;
    uint tiled_rhs_row = kTileSize * t + tile_row;
    tile_lhs[tile_row][tile_col] = ReadLHS(matrix_row, tiled_lhs_col);
    tile_rhs[tile_row][tile_col] = ReadRHS(tiled_rhs_row, matrix_col);
    // Synchronize to make sure the LHS and RHS tiles are loaded.
    barrier();
    for (uint k = 0; k < kTileSize; ++k) {
      acc += tile_lhs[tile_row][k] * tile_rhs[k][tile_col];
    }
    // Synchronize before loading the next tile to make sure acc is valid.
    barrier();
  }
  WriteOut(matrix_row, matrix_col, acc);
}
